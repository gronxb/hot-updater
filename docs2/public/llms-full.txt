# Hot Updater - Complete Documentation

This file contains the full documentation for Hot Updater, a self-hostable OTA updates solution for React Native apps.

---

# Build Plugins: "Bare (CLI) Plugin"
URL: https://hot-updater.dev/docs/build-plugins/bare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/bare.mdx

Use hot-updater with React Native CLI

# Bare Build Plugin

TODO: Document bare React Native CLI integration

---

# Build Plugins: "Expo Plugin"
URL: https://hot-updater.dev/docs/build-plugins/expo
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/expo.mdx

Use hot-updater with Expo

# Expo Build Plugin

TODO: Document Expo integration

---

# Build Plugins: "Rock Plugin"
URL: https://hot-updater.dev/docs/build-plugins/rock
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/rock.mdx

Use hot-updater with Rock

# Rock Build Plugin

TODO: Document Rock integration

---

# Concepts: "How does it work?"
URL: https://hot-updater.dev/docs/concepts/how-it-works
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/concepts/how-it-works.mdx

Understanding the core infrastructure and update decision logic

# How does it work?

`hot-updater` is a system designed for dynamically updating JavaScript bundles in native applications. It operates using the following components and procedures:

## Core Infrastructure

`hot-updater` consists of three key components:

- **Storage**: A place where JavaScript bundles are stored, supporting AWS S3, Cloudflare R2, Supabase Storage, Firebase Storage, etc.
- **Database**: Stores metadata about deployed bundles (version information, etc.) and manages update information.
- **Server**: Determines whether updates are required based on the app's current state, operating through AWS Lambda@Edge, Cloudflare Workers, Supabase Edge Functions, or Firebase Cloud Functions.

Storage and Database are configured using plugins defined in `hot-updater.config.ts`. The Server is initialized and deployed using the `hot-updater init` command.

## Update Decision Logic

`hot-updater` primarily uses UUIDv7 for its operations, with the following update determination process:

### 1. Bundle ID Generation and Management
- Running `hot-updater deploy` invokes a Babel plugin to generate a UUIDv7-formatted Bundle ID.
- This Bundle ID includes the deployment timestamp and is uniquely generated per bundle.

### 2. Initial Native App Build
- The first version of the native app does not have an initial Bundle ID, as it isn't created by `hot-updater deploy` but by the native build process.
- In this case, a minimal Bundle ID (`minBundleId`) in UUIDv7 format, based on the app build timestamp, is used.

### 3. Communication with the Update Server
- The app communicates with the server using the current Bundle ID to verify if the bundle is activated (`enabled=true`).
- If the bundle isn't active, the app forcibly updates (rollbacks) to a previously active bundle.
- If an active bundle newer than the current app version exists, the app updates to the latest available bundle.

### 4. Usage of minBundleId
- The `minBundleId` is determined based on the native app's build timestamp.
- The existence of a native app build ensures the embedded bundle is the latest at that point. Bundles older than the `minBundleId` are ignored.
- Every new deployment generates a new Bundle ID, ensuring accurate and reliable updates.

---

# Concepts: "Plugin System"
URL: https://hot-updater.dev/docs/concepts/plugin-system
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/concepts/plugin-system.mdx

Customize Hot Updater with build, storage, and database plugins

# Plugin System

The `Hot Updater` is designed to be highly customizable through its plugin system. This extensibility allows you to tailor the updater's behavior to fit your specific requirements.

## Build Plugin

The **Build Plugin** is used during the execution of the `hot-updater deploy` command. Its primary function is to manage the build process for generating the required update bundles.

### Supported Plugins

- **`@hot-updater/bare`**: Executes the bundle command through React Native CLI. Bundles through Metro or Re.Pack.
- **`@hot-updater/rock`**: Executes the bundle command through [Rock](https://github.com/callstack/rock)(Formerly RNEF).
- **`@hot-updater/expo`**: Executes the bundle command through Expo.

## Storage Plugin

The **Storage Plugin** is utilized during the `hot-updater deploy` command to upload bundles generated by the Build Plugin. It ensures that the update files are stored in a designated storage solution.

### Supported Plugins

- **`@hot-updater/supabase`**: Provides `supabaseStorage` functionality, leveraging Supabase for storage.
- **`@hot-updater/cloudflare`**: Provides `r2Storage` functionality, leveraging Cloudflare R2 for storage.
- **`@hot-updater/aws`**: Provides `s3Storage` functionality, enabling the use of AWS S3 for storage.
- **`@hot-updater/firebase`**: Provides `firebaseStorage` functionality, utilizing Firebase Storage for storing update bundles.

## Database Plugin

The **Database Plugin** is responsible for storing the metadata required to check for updates. This plugin is activated during the execution of the `hot-updater deploy` command.

### Supported Plugins

- **`@hot-updater/supabase`**: Provides `supabaseDatabase` functionality, using Supabase as a database solution.
- **`@hot-updater/aws`**: Provides `s3Database` functionality, utilizing AWS for database storage.
- **`@hot-updater/cloudflare`**: Provides `d1Database` functionality, leveraging Cloudflare D1 for database storage.
- **`@hot-updater/firebase`**: Provides `firebaseDatabase` functionality, using Firebase Firestore for storing update metadata.

---

# Database Plugins: "AWS S3 Database"
URL: https://hot-updater.dev/docs/database-plugins/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/aws.mdx

Use aws database with hot-updater

# AWS S3 Database

TODO: Document aws database integration

---

# Database Plugins: "Cloudflare D1 Database"
URL: https://hot-updater.dev/docs/database-plugins/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/cloudflare.mdx

Use cloudflare database with hot-updater

# Cloudflare D1 Database

TODO: Document cloudflare database integration

---

# Database Plugins: "Firestore Database"
URL: https://hot-updater.dev/docs/database-plugins/firestore
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/firestore.mdx

Use Firebase Firestore database with hot-updater

# Firebase Firestore Database

TODO: Document firestore database integration

---

# Database Plugins: "Supabase Database"
URL: https://hot-updater.dev/docs/database-plugins/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/supabase.mdx

Use Supabase database with hot-updater

# Supabase Database

TODO: Document Supabase database integration

---

# Get Started: "Basic Usage"
URL: https://hot-updater.dev/docs/get-started/basic-usage
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/get-started/basic-usage.mdx

Learn how to configure and integrate hot-updater into your React Native project

# Basic Usage

This guide walks you through the essential steps to integrate hot-updater into your React Native project.

## Provider Setup

Before configuring the build plugin, you need to set up a provider to handle updates. Hot-updater supports multiple managed providers that handle storage and update distribution.

### Step 1: Install hot-updater

First, install the hot-updater package:

```package-install
npm install hot-updater --save-dev
```

### Step 2: Initialize Your Provider

Run the initialization command to set up your provider interactively:

```package-install
npx hot-updater init
```

This interactive CLI will guide you through:

1. **Build Plugin Selection**: Choose your build system (Bare/React Native CLI, Re.Pack, or Expo)
2. **Provider Selection**: Select from available providers:
   - [Supabase](/docs/managed-providers/supabase)
   - [Firebase](/docs/managed-providers/firebase)
   - [Cloudflare](/docs/managed-providers/cloudflare)
   - [AWS](/docs/managed-providers/aws)

3. **Provider Configuration**: Follow provider-specific prompts for authentication and resource setup.

### Step 3: Generated Configuration

After initialization, two files will be generated:

**`.env.hotupdater`** - Contains provider credentials and configuration:

```
# Example for Supabase
HOT_UPDATER_SUPABASE_URL=https://your-project.supabase.co
HOT_UPDATER_SUPABASE_ANON_KEY=your-anon-key
HOT_UPDATER_SUPABASE_BUCKET_NAME=your-bucket-name
```

**`hot-updater.config.ts`** - Contains provider integration settings:

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});
```


For detailed provider-specific setup instructions, see the [Managed Providers](/docs/managed-providers/supabase) documentation.



The environment variables in `.env` are used only during deployment, not in your app bundle. However, if you're using `react-native-dotenv`, review the [Security guidelines](/docs/policy/security#plugin-token-protection).


### Step 4: Wrap Your Application

Add the HotUpdater wrapper to your main application component:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server-url/api/check-update", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  requestHeaders: {
    // Optional: Add custom headers if needed
  },
  fallbackComponent: ({ progress, status }) => (
    
      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);
```


The update server URL will be provided after running `npx hot-updater init`. Check your terminal output or provider console for the correct URL.


## Plugin Configuration

Configure the build plugin to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```

  
  

First, install the Re.Pack plugin:

```package-install
@hot-updater/repack
```

Then add the following to your `rspack.config.mjs` file:

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```

  
  

Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

Run prebuild to apply the changes:

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


For Expo projects, the plugin automatically generates the native code configuration described in the next section.


  


## Native Code Setup

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.


If you're using Expo with the plugin configured above, this step is handled automatically during prebuild.


### Android


  

For React Native 0.82 and above, modify your `MainApplication.kt`:

```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.hotupdater.HotUpdater

class MainApplication : Application(), ReactApplication {

  override val reactHost: ReactHost by lazy {
    getDefaultReactHost(
      context = applicationContext,
      packageList =
        PackageList(this).packages.apply {
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // add(MyReactNativePackage())
        },
      jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
    )
  }

  override fun onCreate() {
    super.onCreate()
    loadReactNative(this)
  }
}
```

  
  

For React Native versions below 0.82, modify your `MainApplication.kt`:

```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```

  
  

For Java-based projects, modify your `MainApplication.java`:

```java title="android/app/src/main/java/com//MainApplication.java"
package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}
```

  


### iOS


  

For Swift projects, modify your `AppDelegate.swift`:

```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}
```

  
  

For Objective-C projects, modify your `AppDelegate.mm`:

```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```

  


## Next Steps

Now that you've completed the setup, you can start deploying updates:

### Deploy Your First Update

Build and publish an update to your users:

```package-install
npx hot-updater deploy
```

Use the interactive mode for guided deployment:

```package-install
npx hot-updater deploy -i
```

For emergency updates with forced reload:

```package-install
npx hot-updater deploy -i -f
```

### Monitor and Manage Updates

Open the console to track deployments, manage versions, and perform rollbacks:

```package-install
npx hot-updater console
```

### Explore Advanced Features

Learn more about advanced capabilities:

- [Update Strategies](/docs/guides/update-strategies) - Choose between app version and fingerprint strategies
- [Channel Management](/docs/guides/channel-management) - Manage multiple environments and user groups
- [Simulator Testing](/docs/guides/simulator-test) - Test updates in release mode before production
- [Security Best Practices](/docs/policy/security) - Secure your update infrastructure

---

# Get Started: "Introduction"
URL: https://hot-updater.dev/docs/get-started/introduction
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/get-started/introduction.mdx

Self-hostable OTA updates for React Native apps as an alternative to CodePush

# Introduction

Hot Updater is an alternative to `react-native-codepush` that provides self-hostable OTA (Over-The-Air) update capabilities for React Native apps, allowing you to instantly update your JavaScript bundle without going through app stores.





## Motivation

The existing `CodePush` was limited due to its dependency on Microsoft's `AppCenter`. One significant drawback was the lack of a CDN (Content Delivery Network), which could result in slower bundle downloads in certain countries.

Additionally, while `metro` is widely used as a bundler, new alternatives such as `repack` and `vxrn` have emerged. However, tools like `expo update` and `React Native CodePush` only support `metro`, causing dissatisfaction among developers who need more flexibility.

During the development of this solution, I learned about the discontinuation of `AppCenter`, which further emphasized the urgency of creating a better alternative.

### Key Requirements
1. **Freedom of Deployment**
   The solution should allow deployment to any infrastructure that a company uses, providing maximum flexibility.

2. **Bundler Flexibility**
   The solution must support any bundler, not just `metro`, to meet the diverse needs of developers.

### Implementation Approach
To meet these requirements, i introduced a [Plugin System](../concepts/plugin-system). This system allows deployment anywhere as long as the necessary plugin is available. Similarly, developers can configure the solution to work with any bundler of their choice.

## Key Features

- **Self-Hosting**: Full control over your update infrastructure
- **Multi-Platform**: Seamless support for both iOS and Android
- **Web Console**: Intuitive update management interface
- **Version Control**: Robust app versioning with semantic versioning
- **Forced Updates**: Push critical updates when needed

---

# Guides: "Channels"
URL: https://hot-updater.dev/docs/guides/channel-management
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/channel-management.mdx

Manage updates across different environments and user groups

# Channels

Channels help manage updates across different environments (development, staging, production) and deliver updates to specific user groups or separate applications.

Channels are not limited to environment management aloneâ€”they also support managing multiple apps distinctly (e.g., app2, app3, app4), each using its own dedicated channel.

## Channel Overview

- **Default Channel**: Apps default to the `production` channel if no channel is specified.
- **Environment Management**: Clearly separates different environments (`dev`, `staging`, `production`) to ensure accurate application of updates.

## Setting Up Channels

### 1. Specify Channel in Configuration File


  
    Use the `hot-updater channel set` command to specify your desired channel.

    ```package-install
    npx hot-updater channel set 
    ```

    This command will modify the native project files for you. Here's what changes:

    
      
      ```tsx title="ios/HotUpdaterExample/Info.plist"
      HOT_UPDATER_CHANNEL // [!code ++]
      your_set_channel // [!code ++]
      ```
      

      
      ```xml title="android/app/src/main/res/values/strings.xml"
      
          HotUpdaterExample
           // [!code ++]
          your_set_channel
      
      ```
      
    
  
  
    For Expo, you need to add the channel to the plugin configuration in your `app.json` file.

    ```json title="app.json"
    {
      "expo": {
        "plugins": [
          [
            "@hot-updater/react-native",
            {
              "channel": ""
            }
          ]
        ]
      }
    }
    ```
    Replace `` with your desired channel (e.g., `production`).

    After modifying `app.json`, run `prebuild` to apply the changes to the native projects.

    ```package-install
    npx expo prebuild --clean
    ```
  


## Custom Configuration Paths

For projects with non-standard structures or iOS app extensions, you can configure custom paths for platform-specific configuration files in your `hot-updater.config.ts`:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  // ... other configurations
  platform: {
    ios: {
      infoPlistPaths: [
        "ios/YourApp/Info.plist",
        "ios/YourAppExtension/Info.plist", // Include extension Info.plist
        "ios/NotificationService/Info.plist"
      ]
    },
    android: {
      stringResourcePaths: [
        "android/app/src/main/res/values/strings.xml",
        "android/app/src/debug/res/values/strings.xml" // Include additional resource files
      ]
    }
  }
});
```

This is useful when:
- Your iOS project has app extensions (widgets, share extensions, notification services)
- You have multiple Android build variants with different resource paths
- Your project doesn't follow the standard React Native file structure

**Important**: Configure these custom paths before running `hot-updater channel set` commands to ensure all relevant files are updated with the new channel.

### 2. Rebuild App with New Channel

After setting the channel, rebuild your app in Release mode:


  
    **iOS:**
    ```sh
    cd ios && pod install && cd ..
    npx react-native run-ios --mode Release
    ```

    **Android:**
    ```sh
    npx react-native run-android --mode Release
    ```
  
  
    **iOS:**
    ```sh
    npx rock run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx rock run:android --variant Release
    ```
  
  
    **iOS:**
    ```sh
    npx expo run:ios --variant release
    ```

    **Android:**
    ```sh
    npx expo run:android --variant release
    ```
  


### 3. Specify Channel Deployment

You can also specify the target channel directly during deployment:

```package-install
npx hot-updater deploy -p  -c ""
```

Replace `` with your target channel name (e.g., `dev`, `staging`, `production`).

## Retrieving the Current Channel

Use the `HotUpdater.getChannel()` function to retrieve the current release channel within your app.
We recommend displaying this value in your app UI to visually confirm that it's using the intended update channel.

### Example Usage

```tsx
function App() {
  const channel = HotUpdater.getChannel();

  return (
    
      Current Channel: {channel}
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
})(App);
```

## Channel Behavior

- Defaults to `production` if no channel is specified.
- Channels ensure separation of different environments (e.g., `dev`, `staging`, `production`) to apply updates accurately.
- Updates can subsequently be deployed using `hot-updater deploy -c `.
- **Important**: Changing the channel requires rebuilding the native app; simply altering the configuration file or deployment commands will not affect an already built app.

---

# Guides: "Compression Strategy"
URL: https://hot-updater.dev/docs/guides/compression
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/compression.mdx

Choose a compression format for your bundle distribution

# Compression Strategy

Choose a compression format for your bundle distribution.

## Supported Formats

- **`zip`** - Standard ZIP format (DEFLATE algorithm). Fast compression and decompression.
- **`tar.gz`** - TAR archive with GZIP compression (LZ77 algorithm). ~10-15% smaller than ZIP.
- **`tar.br`** - TAR archive with [Brotli](https://github.com/google/brotli) compression. ~20-30% smaller than GZIP. Developed by Google for web compression.

## Configuration

Set `compressStrategy` in your `hot-updater.config.ts`:

```ts
export default defineConfig({
  // ... other options
  compressStrategy: 'tar.gz', // 'zip' | 'tar.gz' | 'tar.br'
});
```

## Usage

After setting the compression strategy, deploy your bundle:

```bash
npx hot-updater deploy -p ios
npx hot-updater deploy -p android
```

The bundle will be compressed and deployed using the specified format.

**How it works:**
- The client app automatically detects the compression format (ZIP, GZIP, or Brotli) and decompresses accordingly
- Users download the compressed bundle, reducing bandwidth usage
- Choose a format with better compression ratio to minimize download size and save users' data


Since the client handles all formats transparently, choose the format with the best compression ratio (`tar.br` or `tar.gz`) to reduce download sizes for your users.

---

# Guides: "Console (Rollback & Force Update)"
URL: https://hot-updater.dev/docs/guides/console
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/console.mdx

Opens a localhost server for rollback, force updates, and git history access

# Console (Rollback & Force Update)

Opens a localhost server based on plugins configured in `hot-updater.config.ts`.
For security reasons, only localhost server is supported at the moment.

**The console provides the following features:**
- Rollback
- Force update flag
- Quick access to git history for updates





## Configuration (Optional)

This is a console configuration that does not affect the bundle.

You can configure additional console settings in the `hot-updater.config.ts` file.

The `storage` and `database` plugins must be exist.

| Option | Description | Default |
| --- | --- | --- |
| `console.gitUrl` | Enables commit shortcuts by linking to git commit hashes | - |
| `console.port` | Sets the console server port | `1422` |

```ts title="hot-updater.config.ts"
export default defineConfig({
  console: { // [!code hl]
    port: 3000, // [!code hl]
  }, // [!code hl]
  build: ...,
  storage: ...,
  database: ...,
});

```

## Usage
Execute the following command:

```package-install
npx hot-updater console
```



## Rollback

When you set a bundle's `enabled` status to `false` in the console, users who have that bundle will immediately force update to the **previous bundle**.



## Force Update
When you set a bundle's `shouldForceUpdate` status to `true` in the console, users who have that bundle will immediately force update to the **latest bundle**.



## Git URL

You can set the git URL in the `hot-updater.config.ts` file.

```ts title="hot-updater.config.ts"
export default defineConfig({
  console: {
    gitUrl: "", // e.g. https://github.com/gronxb/hot-updater // [!code hl]
  },
});
```
When you set the git URL, the commit hash will be clickable and redirect you to the corresponding commit in your repository.

---

# Guides: "Deploy"
URL: https://hot-updater.dev/docs/guides/deploy
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/deploy.mdx

Deploy updates to specified platforms using the hot-updater CLI

# Deploy
This command is used to deploy the update to the specified platform.



## Checklist
1. Ensure `hot-updater.config.ts` is properly configured.
2. Wrap your components using `HotUpdater.wrap`.
3. Register the `babel-plugin`.
4. Include the native code.

If you haven't completed these steps, refer to the [Supabase Provider](/docs/managed-providers/supabase) guide.

## Options

```
Options:
  -p, --platform                     specify the platform (choices: "ios", "android")
  -t, --target-app-version   specify the target app version (semver format e.g. 1.0.0, 1.x.x)
  -f, --force-update                           force update the app (default: false)
  -o, --bundle-output-path   the path where the bundle.zip will be generated
  -i, --interactive                            interactive mode (default: false)
  -c, --channel                       specify the channel to deploy (default: "production")
  -m, --message                       Specify a custom message for this deployment. If not provided, the latest git commit message will be used as the deployment message
  -h, --help                                   display help for command
```

## Usage

### Interactive Mode

Interactive mode guides you through the deployment steps via keyboard inputs.

Execute the following command:

```package-install
npx hot-updater deploy -i
```

The `-i` (or `--interactive`) flag enables interactive keyboard input.
- This mode allows you to proceed through deployment steps interactively.

### For Continuous Deployment (CD) Pipelines

Use this mode for automating deployment in CI/CD pipelines.

Run the following command:

```package-install
npx hot-updater deploy -p 
```

- This mode is suitable for Continuous Deployment (CD) pipelines.

### Force Update

Deploy a forced update for emergency purposes. This will immediately apply the update.

Run the following command:

```package-install
npx hot-updater deploy -p  -f
```

The `-f` (or `--force-update`) flag enables force update.

### Channel

The `-c` (or `--channel`) flag specifies the release channel.

Run the following command:

```package-install
npx hot-updater deploy -p  -c ""
```

The `-c` (or `--channel`) flag specifies the release channel. The default value is `production`.

For more details about channels, refer to the [Channel Guide](/docs/guides/channel-management).

### Message

The `-m` (or `--message`) flag specifies the message.

Run the following command:

```package-install
npx hot-updater deploy -p  -m ""
```

## Force Update Flag Difference

| Update Type   | When Applied                                              | How to Enable                              |
|---------------|----------------------------------------------------------|-------------------------------------------|
| Default       | Downloads the update bundle in the background and applies it when the user restarts the app. | Default setting                           |
| Force Update  | Downloads the update bundle and applies it immediately.   | Use the `--force-update` flag or console. |

---

# Guides: "Simulate Release Mode"
URL: https://hot-updater.dev/docs/guides/simulator-test
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/simulator-test.mdx

Test hot-updater in Release mode on simulators

# Simulate Release Mode

Since hot-updater does not work in dev environment, you need to test it in Release mode as shown below.

## Checklist
- Make sure `hot-updater.config.ts` is properly configured.
- Make sure `HotUpdater.wrap` is properly implemented.


## Step 1: Simulator Release Mode

Run your app in Release mode to test hot-updater (it doesn't work in dev mode).


  
    **iOS:**
    ```sh
    cd ios && pod install && cd ..
    npx react-native run-ios --mode Release
    ```

    **Android:**
    ```sh
    npx react-native run-android --mode Release
    ```
  
  
    **iOS:**
    ```sh
    npx rock run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx rock run:android --variant Release
    ```
  
  
    **iOS:**
    ```sh
    npx expo run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx expo run:android --variant release
    ```
  


## Step 2: Deploy

Deploy with interactive mode and force update flag enabled in hot-updater deploy mode.

When [HotUpdater.wrap](/docs/react-native-api/wrap) is set up, updates will be applied when you restart the app.

You can check the update progress status using [useHotUpdaterStore](/docs/react-native-api/useHotUpdaterStore).





### For Normal Deployment

This is the standard deployment mode. After an update is created, users need to restart their app after downloading the bundle for the update to take effect.

```package-install
npx hot-updater deploy -i
```


### For Emergency Deployment

This is the emergency deployment mode. After an update is created, the bundle will automatically reload and apply the update as soon as users download it.

```package-install
npx hot-updater deploy -i --force-update
```


## Step 3: Rollback



When you set a bundle's `enabled` status to `false` in the console, users who have that bundle will immediately force update to the **previous bundle**.

Open the console and set the bundle's `enabled` status to `false`.

```package-install
npx hot-updater console
```

---

# Guides: "App Version Update Strategy"
URL: https://hot-updater.dev/docs/guides/update-strategies/app-version
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/update-strategies/app-version.mdx

Target specific native app versions for updates

# App Version Update Strategy

The "App Version" update strategy in `hot-updater` allows you to target specific native app versions when deploying updates. Unlike the `fingerprint` strategy, which compares hash values to check for native code changes, this strategy applies updates only to the app version specified with the `-t` (or `--target-app-version`) option during the `hot-updater deploy` command.

## When to Use It?

- You might choose this strategy if managing fingerprints feels cumbersome or if you prefer to specify update targets more explicitly.

## Configuration

You can enable this feature by setting the `updateStrategy` option to `appVersion` in your `hot-updater.config.ts` file.

```typescript title="hot-updater.config.ts"
export default defineConfig({
  // ... other configurations
  updateStrategy: "appVersion",
});
```

## Client-Side Configuration with `getUpdateSource`

When using the app version strategy in your React Native application, you need to configure the `getUpdateSource` function with the `updateStrategy` set to `"appVersion"`. This ensures that the client app sends the correct app version when checking for updates.

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server.com/api/update-check", {
    updateStrategy: "appVersion", // Configure for app version strategy
  }),
  // ... other options
})(App);
```

The `getUpdateSource` function will automatically construct the correct endpoint URL for the app version strategy:
`GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`

## Specifying App Version During Deployment

When using the "App Version" strategy, you must specify the target app version for the update using the `-t` (or `--target-app-version`) option in the `hot-updater deploy` command.

```package-install
npx hot-updater deploy -p  -t "1.x.x"
```

The `-t` option accepts not only single versions but also various range expressions.

## Target App Version Range Expression Table

The following table shows the version range expressions you can use with the `-t` option and their meanings. This table is identical to the Target App Version specification for the `hot-updater deploy` command.

| Range Expression | Who gets the update                                                              |
| :--------------- | :------------------------------------------------------------------------------- |
| `1.2.3`          | Only devices running the specific binary app store version `1.2.3` of your app   |
| `*`              | Any device configured to consume updates from your CodePush app                  |
| `1.2.x`          | Devices running major version `1`, minor version `2` and any patch version of your app |
| `1.2.3 - 1.2.7`  | Devices running any binary version between `1.2.3` (inclusive) and `1.2.7` (inclusive) |
| `>=1.2.3 =1.2.0 =1.2.3 =1.2.3 <2.0.0`                                                   |

## Endpoint Testing

When using the `appVersion` strategy, the update check endpoint typically follows this format:
`GET /check-update/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`

Here's an example of testing this endpoint using `curl`. You'll need to replace `:platform`, `:targetAppVersion`, etc., with actual values.

```bash
curl "https://your-update-endpoint.com/check-update/app-version/ios/1.0.0/production/00000000-0000-0000-0000-000000000000/00000000-0000-0000-0000-000000000001"
```

-   `:platform`: Specifies the platform, such as `ios` or `android`.
-   `:targetAppVersion`: The current version of the client app. This value is used to determine if the app is eligible for an update.
-   `:channel`: The channel name you want to check for updates (e.g., `default`, `staging`).
-   `:minBundleId`: The minimum bundle ID supported by the client. (If unknown for testing, you can use `00000000-0000-0000-0000-000000000000`).
-   `:bundleId`: The client's current bundle ID.

This request allows you to verify if an update is available for the specified app version.

---

# Guides: "Fingerprint Update Strategy"
URL: https://hot-updater.dev/docs/guides/update-strategies/fingerprint
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/update-strategies/fingerprint.mdx

Use fingerprint hashing for precise update targeting

# Fingerprint Update Strategy

The "Fingerprint" update strategy in `hot-updater` leverages Expo's [`@expo/fingerprint`](https://expo.dev/blog/fingerprint-your-native-runtime) library to track and manage changes in your project's native code. This mechanism significantly enhances the stability of app updates by preventing the delivery of JavaScript bundles incompatible with the native code.

## Why Choose Fingerprint Strategy?

The Fingerprint strategy ensures **OTA update compatibility** by preventing incompatible JavaScript bundles from being delivered to your users. It automatically detects when native code changes would break compatibility and blocks unsafe OTA deployments.

### Fingerprint vs App Version Strategy

- **Fingerprint Strategy** (Recommended): Automatically detects native compatibility changes and prevents incompatible OTA updates
- **App Version Strategy**: Manually specify version targets, but no automatic compatibility checking

Choose Fingerprint if you want automatic protection against incompatible updates. Choose App Version if you prefer manual control over update targeting.

## How It Works: Real Development Scenarios

### Scenario 1: JavaScript/UI Changes âœ… OTA Update
```javascript
// âœ… These changes are safe for OTA updates
// - Updating component logic
// - Changing styles and layouts  
// - Adding new screens
// - Modifying business logic
// - Updating API calls
```
**Result**: Fingerprint stays the same â†’ OTA update deployed safely

### Scenario 2: Native Code Changes âš ï¸ Native Rebuild Required
```bash
# âš ï¸ These changes require native rebuild
# - Installing new native modules (react-native-camera)
# - Updating React Native version
# - Modifying native iOS/Android code
# - Changing build configurations
```
**Result**: Fingerprint changes â†’ OTA deployment blocked â†’ Native rebuild needed

### The Safety Net
When you try to deploy an OTA update but the fingerprint has changed:
```bash
$ pnpm hot-updater deploy
âŒ Fingerprint mismatch detected!
ðŸ’¡ Native code has changed. You need to:
1. Run: pnpm hot-updater fingerprint create
2. Rebuild and resubmit your app
3. Then deploy OTA updates
```

## Essential Workflow: Before App Store Submission

### Step 1: Generate Fingerprint Before Native Build
Before building your app for the App Store, always generate the fingerprint:

```package-install
npx hot-updater fingerprint create
```

This command:
- Calculates a hash representing your native code state
- Updates `ios/YourApp/Info.plist` with the fingerprint
- Updates `android/app/src/main/res/values/strings.xml` with the fingerprint

### Step 2: Build and Submit to App Store
Now build your native app with the embedded fingerprint and submit to App Store.

### Step 3: Deploy OTA Updates Safely
After your app is live, you can deploy JavaScript-only updates:

```package-install
npx hot-updater deploy
```

The system automatically ensures only compatible updates reach your users.

## Quick Setup

### 1. Enable Fingerprint Strategy
Fingerprint is the default strategy, but you can explicitly set it:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint", // This is the default
});
```

### 2. Include Additional Files (Optional)
If you have extra files that affect native compatibility:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint",
  fingerprint: {
    extraSources: [
      "config/native-config.json", // Custom native configurations
      "scripts/post-build.sh",     // Build scripts that affect native code
    ],
    debug: true, // See detailed fingerprint calculation info
  },
});
```

## Client-Side Configuration with `getUpdateSource`

When using the fingerprint strategy in your React Native application, you need to configure the `getUpdateSource` function with the `updateStrategy` set to `"fingerprint"`. This ensures that the client app sends the correct fingerprint hash when checking for updates.

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server.com/api/update-check", {
    updateStrategy: "fingerprint", // Configure for fingerprint strategy
  }),
  // ... other options
})(App);
```

The `getUpdateSource` function will automatically construct the correct endpoint URL for the fingerprint strategy:
`GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

## Managing and Updating Fingerprints

It's crucial to check and, if necessary, update the fingerprint whenever changes are made to the native code.

1.  **Check Current Fingerprint**:

    ```package-install
    npx hot-updater fingerprint
    ```

    This command calculates the current project's fingerprint and shows whether it matches the stored value.

2.  **Create a New Fingerprint**:
    If the command above indicates a mismatch, you must generate a new fingerprint using:

    ```package-install
    npx hot-updater fingerprint create
    ```

    **Important**: After creating a new fingerprint, you **must rebuild your app**. This ensures that the updated native environment and the new fingerprint are correctly incorporated into the app binary, preventing compatibility issues with apps built using the previous fingerprint.

## Advanced: Multiple App Targets

### What `fingerprint create` Does Automatically
When you run `pnpm hot-updater fingerprint create`, it automatically:
- Updates your main `ios/YourApp/Info.plist` 
- Updates your main `android/app/src/main/res/values/strings.xml`
- Embeds the fingerprint hash in these files

### When You Need Additional Configuration
**Only configure additional paths if you have:**
- iOS app extensions (widgets, share extensions, watch apps)
- Multiple Android build variants with separate string files
- Non-standard project structure

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint",
  platform: {
    ios: {
      infoPlistPaths: [
        // Main app (handled automatically)
        "ios/YourApp/Info.plist",
        // Additional targets you need to include
        "ios/YourAppWidget/Info.plist",
        "ios/YourAppExtension/Info.plist"
      ]
    },
    android: {
      stringResourcePaths: [
        // Main strings (handled automatically)  
        "android/app/src/main/res/values/strings.xml",
        // Additional build variants
        "android/app/src/debug/res/values/strings.xml"
      ]
    }
  }
});
```

ðŸ’¡ **Most projects don't need this configuration** - the default behavior handles standard React Native projects perfectly.

## Fingerprint File Example (`fingerprint.json`)

```json
{
  "ios": {
    "hash": "11142b9062165fa48665f5efa095dd94e9e45eb0",
    // ... other details
  },
  "android": {
    "hash": "c763ed5729a0bcccf23248ee0183ddf9016c2e6e",
    // ... other details
  }
}
```


## Endpoint Testing

You can test if the update check endpoint, configured via the `hot-updater init` command, is working correctly. When using the `fingerprint` strategy, the endpoint format is typically:

*   `GET /check-update/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

Example of testing with `curl`:

```bash
curl "https://your-update-endpoint.com/check-update/fingerprint/ios/11142b9062165fa48665f5efa095dd94e9e45eb0/production/00000000-0000-0000-0000-000000000000/00000000-0000-0000-0000-000000000001"
```

**Request Parameter Descriptions:**

*   `:platform`: The platform, such as `ios` or `android`.
*   `:fingerprintHash`: The current fingerprint hash of the client app.
*   `:channel`: The channel name you want to check for updates (e.g., `default`, `staging`).
*   `:minBundleId`: The minimum bundle ID supported by the client (this value is updated when the native app is rebuilt. If unknown for testing, you can use `00000000-0000-0000-0000-000000000000`).
*   `:bundleId`: The client's current bundle ID.

This request allows you to verify if an update is available for a specific fingerprint hash and channel.

---

# Integration Plugins: "Datadog"
URL: https://hot-updater.dev/docs/integration-plugins/datadog
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/datadog.mdx

Upload source maps to Datadog for error tracking

# Datadog Source Maps Plugin

The `withDatadog()` plugin for hot-updater enables automatic sourcemap upload to Datadog during the update bundle build process.

This helps you track production crashes with accurate stack traces tied to your React Native source code.

## Prerequisites

- Datadog Account: Sign up here if you don't have one.
- Auth Token: Generate a token from your Datadog dashboard. This must be defined as the environment variable `DATADOG_API_KEY`.
- Datadog host: in order to communicate with Datadog, you need to specify the host to which the Auth token refers using the environment variable `DATADOG_HOST` (e.g., `DATADOG_HOST=datadoghq.eu`)
- Install the plugin:

```package-install
@hot-updater/datadog-plugin @datadog/datadog-ci
```

## Step 1: Wrap Your Build Plugin

Use `withDatadog()` to wrap any compatible build plugin such as bare.

Once wrapped, sourcemaps will automatically be uploaded to Datadog when running the `hot-updater deploy` process.


  

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: withDatadog(
    bare({
      enableHermes: false, // or true, depending if you want to use it
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```



```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withDatadog(
    expo({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```




```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withDatadog(
    rock({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```






When `withDatadog()` wraps your build plugin, all generated sourcemaps are uploaded to Datadog automatically during the `hot-updater deploy` process.


## Step 3: Deploy

Now, every time you deploy, sourcemaps will be automatically uploaded to Datadog.

```package-install
npx hot-updater deploy -i
```

---

# Integration Plugins: "Re.Pack"
URL: https://hot-updater.dev/docs/integration-plugins/repack
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/repack.mdx

Integration plugin for Re.Pack bundler

# Re.Pack Plugin

Re.Pack is a modern bundler for React Native.

The `@hot-updater/repack` plugin is a plugin for the [Re.Pack](https://re-pack.dev/) bundler.

It is used to set the bundle ID (uuidv7) and channel at build time.

If you don't do this, you'll get an error saying there's no bundle ID when running the `hot-updater deploy` command.


## Installation

```package-install
@hot-updater/repack
```


## Usage

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```

---

# Integration Plugins: "Sentry"
URL: https://hot-updater.dev/docs/integration-plugins/sentry
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/sentry.mdx

Upload source maps to Sentry for error tracking

# Sentry Source Maps Plugin

The `withSentry()` plugin for hot-updater enables automatic sourcemap upload to Sentry during the update bundle build process.

This helps you track production crashes with accurate stack traces tied to your React Native source code.

## Prerequisites

- Sentry Account: Sign up here if you don't have one.
- Auth Token: Generate a token with the project:releases and org:read scopes from your Sentry dashboard.
- Install the plugin:

```package-install
@hot-updater/sentry-plugin
```

## Step 1: Configure Sentry


  
    

    You need to configure Metro. Please refer to the [Sentry documentation](https://docs.sentry.io/platforms/react-native/manual-setup/metro/) above for detailed setup instructions.

    ```js title="metro.config.js"
    const { getDefaultConfig } = require("@react-native/metro-config");
    const { withSentryConfig } = require("@sentry/react-native/metro");

    const config = getDefaultConfig(__dirname);
    module.exports = withSentryConfig(config);
    ```
  
  

  You need to configure Re.Pack.

```package-install
repack-plugin-sentry
```

```js title="rspack.config.mjs"
export default {
  // ... your other config
  plugins: [
    // ... your other plugins
    new SentryDebugIdPlugin(), // [!code ++]
  ],
};
```
  




## Step 2: Wrap Your Build Plugin

Use `withSentry()` to wrap any compatible build plugin such as bare.

Once wrapped, sourcemaps will automatically be uploaded to Sentry when running the `hot-updater deploy` process.


  

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: withSentry(
    bare({
      enableHermes: false,
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```



```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withSentry(
    expo({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```




```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withSentry(
    rock({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```






When `withSentry()` wraps your build plugin, all generated sourcemaps are uploaded to Sentry automatically during the `hot-updater deploy` process.


## Step 3: Deploy

Now, every time you deploy, sourcemaps will be automatically uploaded to Sentry.

```package-install
npx hot-updater deploy -i
```

---

# Managed-Hosted: "AWS S3 Storage + Lambda@Edge Function"
URL: https://hot-updater.dev/docs/managed-providers/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/aws.mdx

Set up hot-updater with AWS S3 and Lambda@Edge

# AWS S3 Storage + Lambda@Edge Function

This guide walks you through setting up `hot-updater` with AWS S3 Storage and Lambda@Edge Function in a React Native project. You'll configure the environment, install required packages, and initialize AWS for seamless updates.



## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **AWS Account**: Sign up at [AWS](https://aws.amazon.com) if you don't have one.
- **AWS CLI**: Install the AWS CLI and configure your credentials.

## Required AWS Permissions

Hot Updater requires specific AWS IAM permissions for setup and ongoing usage:

### 1. Initialization (One-Time Setup)

Used for `hot-updater init`:
* `AmazonS3FullAccess`: Create and read S3 buckets.
* `AWSLambda_FullAccess`: Create and update Lambda functions.
* `CloudFrontFullAccess`: Manage CloudFront distributions.
* `IAMFullAccess`: Create IAM roles for Lambda@Edge.
* `SSMFullAccess`: Create Access to SSM Parameters for storing CloudFront key pairs.

### 2. Ongoing Usage

Used for `hot-updater deploy` and `hot-updater console`:
* `AmazonS3FullAccess`: Manage bundles and metadata in the S3 bucket.

For ongoing usage, create a separate access token with limited permissions.

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure AWS

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select AWS + Lambda@Edge as the provider for handling updates.
During the setup, you will be prompted to:
1. **Choose AWS Login Method**: Select between AWS Access Key or SSO login
2. **Enter AWS Credentials**: Input your AWS credentials with required permissions
3. **Select Region**: Choose an AWS region for your S3 bucket
4. **Select S3 Bucket**: Choose an existing bucket or create a new one
5. **Create IAM Role**: Create or select an IAM role for Lambda@Edge
6. **Deploy Lambda Function**: Deploy the Lambda@Edge function to handle updates
7. **Create/Update CloudFront Distribution**: Create or update a CloudFront distribution

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
# This key was generated via SSO login and may expire. Update it with an S3FullAccess and CloudFrontFullAccess key.
HOT_UPDATER_S3_ACCESS_KEY_ID=your-access-key-id
# This key was generated via SSO login and may expire. Update it with an S3FullAccess and CloudFrontFullAccess key.
HOT_UPDATER_S3_SECRET_ACCESS_KEY=your-secret-access-key

HOT_UPDATER_S3_BUCKET_NAME=your-s3-bucket-name
HOT_UPDATER_S3_REGION=your-region
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating AWS with your project.

```ts title="hot-updater.config.ts"

import "dotenv/config";

const commonOptions = {
  bucketName: process.env.HOT_UPDATER_S3_BUCKET_NAME!,
  region: process.env.HOT_UPDATER_S3_REGION!,
  credentials: {
    accessKeyId: process.env.HOT_UPDATER_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.HOT_UPDATER_S3_SECRET_ACCESS_KEY!,
  },
};

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: s3Storage(commonOptions),
  database: s3Database({
    ...commonOptions,
    cloudfrontDistributionId: process.env.HOT_UPDATER_CLOUDFRONT_DISTRIBUTION_ID!,
  }),
});
```

## Step 4: Change `.env` file (Optional)

By this point, the .env file should already be created. The token inside was generated when you ran the `hot-updater init` command.

The token may have excessive permissions due to infrastructure setup or expire if SSO was used.

To avoid issues, update it with a permanent token with `S3FullAccess` and `CloudFrontFullAccess`.

```ts title=".env"
HOT_UPDATER_S3_ACCESS_KEY_ID=your-access-key-id
HOT_UPDATER_S3_SECRET_ACCESS_KEY=your-secret-access-key
```


## Step 5: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https:///api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```


## Step 6: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.





## Step 7: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS


```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your AWS dashboard for the newly created bucket, Lambda@Edge function, and CloudFront distribution.
2. Test the HotUpdater integration in your React Native app.


You're all set! ðŸŽ‰ Start using hot-updater with AWS for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Cloudflare Provider"
URL: https://hot-updater.dev/docs/managed-providers/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/cloudflare.mdx

Set up hot-updater with Cloudflare R2 and D1

# Cloudflare Provider

This guide walks you through setting up `hot-updater` with Cloudflare in a React Native project. You'll configure the environment, install required packages, and initialize Cloudflare for seamless updates.



## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **Cloudflare Account**: Sign up at [Cloudflare](https://cloudflare.com) if you don't have one.
- **Cloudflare API Token**: Create an API Token at https://dash.cloudflare.com/{your-account-id}/api-tokens with **R2 Edit** & **D1 Edit** permissions

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Cloudflare

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Cloudflare as the provider for handling updates.

During the setup, you will be prompted to:
1. **Login to Cloudflare**: Sign in to your Cloudflare account with wrangler
2. **Enter R2 & D1 API Token**: Input your API token with R2 and D1 permissions
3. **Select R2 Bucket**: Choose an existing R2 bucket or create a new one
4. **Select D1 Database**: Choose an existing D1 database or create a new one
5. **Run D1 Migration**: Execute database migrations for D1
6. **Deploy Worker**: Deploy the Cloudflare Worker for update management

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID=your-account-id
HOT_UPDATER_CLOUDFLARE_R2_BUCKET_NAME=your-r2-bucket-name
HOT_UPDATER_CLOUDFLARE_D1_DATABASE_ID=your-d1-database-id
HOT_UPDATER_CLOUDFLARE_API_TOKEN=your-api-token
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Cloudflare with your project.

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: r2Storage({
    bucketName: process.env.HOT_UPDATER_CLOUDFLARE_R2_BUCKET_NAME!,
    accountId: process.env.HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.HOT_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
  database: d1Database({
    databaseId: process.env.HOT_UPDATER_CLOUDFLARE_D1_DATABASE_ID!,
    accountId: process.env.HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.HOT_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
});

```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://..workers.dev/api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.






## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Cloudflare dashboard for the newly created bucket, D1 database, and worker.
2. Test the HotUpdater integration in your React Native app.


You're all set! ðŸŽ‰ Start using hot-updater with Cloudflare for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Firebase Provider"
URL: https://hot-updater.dev/docs/managed-providers/firebase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/firebase.mdx

Set up hot-updater with Firebase Storage and Firestore

# Firebase Provider

This guide walks you through setting up `hot-updater` with Firebase in a React Native project. You'll configure the environment, install required packages, and initialize Firebase for seamless updates.



## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **Firebase Project**: Create a new project at [Firebase](https://firebase.google.com) if you donâ€™t have one.
- **Firebase Storage**: Create a new storage bucket at [Firebase](https://firebase.google.com) if you donâ€™t have one.
- **Firestore**: Create a new firestore database at [Firebase](https://firebase.google.com) if you donâ€™t have one.

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Firebase

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Firebase as the provider for handling updates.

During the setup, you will be prompted to:
1. **Create or Select a Firebase Project**: Choose an existing project or create a new one.
2. **Configure Storage**: Select an existing storage bucket or create a new public bucket to store updates.
3. **Deploy Firestore Indexes**: create a new one to store updates.
4. **Deploy Functions**: Deploy a Firebase Function v2 called `hot-updater`.
5. **Add IAM Policy**: Add a new IAM policy to the service account of the function.

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_FIREBASE_PROJECT_ID=your-project-id
HOT_UPDATER_FIREBASE_STORAGE_BUCKET=your-bucket-name
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=your-credentials.json
```




If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Firebase with your project.
- `.env`: **IMPORTANT**:
Make sure to set the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to the path of your downloaded Firebase credentials JSON file.
This is critical for Firebase authentication to work properly.
For more details, see: https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments

```js title=".env"
HOT_UPDATER_FIREBASE_PROJECT_ID=your-project-id
HOT_UPDATER_FIREBASE_STORAGE_BUCKET=your-bucket-name
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=your-credentials.json
```

```ts title="hot-updater.config.ts"
import 'dotenv/config';

// https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments
// Check your .env file and add the credentials
// Set the GOOGLE_APPLICATION_CREDENTIALS environment variable to your credentials file path
// Example: GOOGLE_APPLICATION_CREDENTIALS=./firebase-adminsdk-credentials.json
const credential = admin.credential.applicationDefault();

export default defineConfig({
  build: bare({
    enableHermes: true,
  }),
  storage: firebaseStorage({
    projectId: process.env.HOT_UPDATER_FIREBASE_PROJECT_ID!,
    storageBucket: process.env.HOT_UPDATER_FIREBASE_STORAGE_BUCKET!,
    credential,
  }),
  database: firebaseDatabase({
    projectId: process.env.HOT_UPDATER_FIREBASE_PROJECT_ID!,
    credential,
  }),
});
```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https:///api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
@hot-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.





## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Firebase dashboard for the newly created firebase function.
2. Test the HotUpdater integration in your React Native app.


Youâ€™re all set! ðŸŽ‰ Start using hot-updater with Firebase for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Supabase Provider"
URL: https://hot-updater.dev/docs/managed-providers/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/supabase.mdx

Set up hot-updater with Supabase Storage and Database

# Supabase Provider

This guide walks you through setting up `hot-updater` with Supabase in a React Native project. You'll configure the environment, install required packages, and initialize Supabase for seamless updates.



## Prerequisites

Before you begin, make sure the following are ready:
- **Docker Or OrbStack**: Install it via [Docker](https://docs.docker.com/get-docker/) or [OrbStack](https://orbstack.dev/).
- **Node.js**: Version 20 or later is recommended.
- **Supabase CLI**: Install it via `npx supabase`.
- **Supabase Account**: Sign up at [Supabase](https://supabase.com) if you don't have one.


## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Supabase

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx -y supabase login
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Supabase as the provider for handling updates.

During the setup, you will be prompted to:
1. **Create or Select a Supabase Organization**: Choose an existing organization or create a new one.
2. **Create or Select a Project**: Choose an existing project or create a new one within your organization.
3. **Configure Storage**: Select an existing storage bucket or create a new public bucket to store updates.
4. **Database Migration**: create a new one to store updates.
5. **Deploy Edge Function**: Deploy a Supabase Edge Function called `update-server`.

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_SUPABASE_ANON_KEY=your-anon-key
HOT_UPDATER_SUPABASE_BUCKET_NAME=your-bucket-name
HOT_UPDATER_SUPABASE_URL=https://your-project-id.supabase.co
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Supabase with your project.

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});
```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://.supabase.co/functions/v1/update-server", {  // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }),  // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.






## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Supabase dashboard for the newly created bucket and edge function.
2. Test the HotUpdater integration in your React Native app.


You're all set! ðŸŽ‰ Start using hot-updater with Supabase for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Policy: "When to Submit Your App for Review"
URL: https://hot-updater.dev/docs/policy/app-review
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/policy/app-review.mdx

Understanding when app store review is required vs HotUpdater updates

# When to Submit Your App for Review

`HotUpdater` enables seamless updates to JavaScript (JS) files and assets required by your app, bypassing the app store review process in many cases. However, certain changes, particularly those involving native code (e.g., written in Swift/Objective-C for iOS or Kotlin/Java for Android), require app store review. Below, we outline when you need to submit your app for review and when `HotUpdater` can handle updates independently.

## Scenarios Requiring App Store Review (Native Code Changes)


1. **Initial Integration of `HotUpdater`**  
   During the first integration of `HotUpdater`, native code modifications are required. This necessitates submitting your app for app store review.

2. **Native Code Changes**  
   Any updates to native code, such as Swift, Objective-C, Kotlin, or Java, require an app store review before the changes can be distributed.

3. **Installing Native-Dependent Libraries**  
   When using third-party libraries in React Native that modify native code, your app must go through app store review. A key indicator of native changes is the need for commands like:
   ```bash
   cd ios && pod install && cd ..
   ```


## Scenarios Compatible with HotUpdater (No App Store Review)

Certain updates can be performed entirely via HotUpdater, allowing you to bypass the app store review process:

### JavaScript Code Updates

Updates that only modify JS code can be handled by HotUpdater without review.

```tsx
   export default function App() {
       return (
           
             Hello // [!code --]
             Update Hello // [!code ++]
           
       );
   }
   ```

### Asset Updates via `require`

Changes to assets referenced using `require` (e.g., images or media files) can also be distributed via HotUpdater.

```tsx
    // [!code --]
    // [!code ++]
   ```


### JavaScript Library Updates

Updates that involve only JS library changes are compatible with HotUpdater:

```sh
> npm install lodash zustand ...
```

## Understanding HotUpdater Package Versioning

The HotUpdater versioning system helps determine whether app store review is necessary:
| **Version Type** | **Example**       | **Changes**                                                                 | **Review Required?**        |
|-------------------|-------------------|-----------------------------------------------------------------------------|-----------------------------|
| Patch Version     | `0.5.10 â†’ 0.5.11` | Only JS logic is updated.                                                  | No                          |
| Minor Version     | `0.5.10 â†’ 0.6.0` | Updates include JS changes and minor optimizations in the native code.     | Yes                         |
| Major Version     | `0.5.10 â†’ 1.0.0` | Significant changes to native code, often involving feature enhancements.  | Yes                         |

If the version change only affects the `0.5.x` part of the package (patch version), you can update the `hot-updater` package without requiring an app store review, as the updates are limited to JS logic. However, if the `0.x.0` portion changes (major or minor version), it indicates changes in the native code. In these cases, the app must go through the app store review process.

### Key Notes on Versioning
-	Patch Versions (x.x.Patch): Updates limited to JS logic (e.g., bug fixes or performance improvements). No app store review required.
-	Minor Versions (x.Minor.x): May include minor changes to native code, requiring app store review.
-	Major Versions (Major.x.x): Introduce significant updates to native code, always requiring app store review.

### Summary

To ensure a smooth update process:
-	Use HotUpdater for JS updates and asset changes to avoid app store reviews.
-	Submit your app for review when native code changes or third-party libraries affecting native code are integrated.
-	Follow HotUpdater versioning guidelines to determine when a review is required.

---

# Policy: "Security"
URL: https://hot-updater.dev/docs/policy/security
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/policy/security.mdx

Best practices for protecting plugin tokens and sensitive data

# Security


## Plugin Token Protection

Developers may worry that sensitive tokens defined in the `hot-updater.config.ts` file might be bundled into the app and exposed in production.

Using environment variables is simply for populating the token value in the `hot-updater.config.ts` file. This is, in fact, unrelated to React Native.

```ts title="hot-updater.config.ts"
import "dotenv/config";

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});

```

## Clarification

The `hot-updater.config.ts` file is not included in the appâ€™s build. Instead, it serves as a configuration layer specifically for communicating with the `hot-updater` CLI. As a result, sensitive tokens defined in this file are not part of the distributed application code.

What is actually included in the appâ€™s build is as follows:
```ts
export default HotUpdater.wrap({
  source: "https://",
});
```

Here, the source URL is included in the app code, but sensitive environment variables, such as `HOT_UPDATER_SUPABASE_ANON_KEY` tokens, are not bundled.

## Potential Token Exposure


If you're **not** using react-native-dotenv, tokens won't be included in your app by default. This is a guideline for projects using react-native-dotenv.

Using tools like react-native-dotenv can expose sensitive tokens in your app build. To avoid this, only include non-sensitive or publicly safe variables in your configuration.


If youâ€™re using tools like `react-native-dotenv` to read environment variables and inject them into the app during runtime, sensitive tokens might be exposed. To avoid this, ensure that only non-sensitive or publicly safe data is included in your app build.

### Example: If you are using `react-native-dotenv` Babel Configuration

To ensure safe handling of environment variables, you can whitelist only the necessary variables using `react-native-dotenv` in your Babel configuration:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin',
    [
      'module:react-native-dotenv',
      {
        envName: 'APP_ENV',
        allowlist: ['HOT_UPDATER_SUPABASE_ANON_KEY', 'HOT_UPDATER_CLOUDFLARE_API_TOKEN'], âŒ Do not add private keys to allowlist // [!code --]
        allowlist: ['HOT_UPDATER_SUPABASE_URL'], // âœ… Only add public keys that are safe to expose to allowlist // [!code ++]
        path: '.env.hotupdater', // âœ… Use .env.hotupdater file separate from .env file
      },
    ],
  ],
};
```

## Best Practices

1. Restrict Exposure: Only include environment variables that are safe for public access in your app build.
2. Use Whitelists: Use tools like react-native-dotenv to define a whitelist of allowed environment variables.
3. Keep Sensitive Data Out of Builds: Store sensitive data securely on your server or backend, and ensure it is only accessed during server-side operations.
4. Use `react-native-keys` to manage keys.

---

# React Native API: "addEventListener"
URL: https://hot-updater.dev/docs/react-native-api/addListener
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/addListener.mdx

Listen to update events

# `HotUpdater.addEventListener()`

The `addEventListener` function allows you to listen for specific events emitted by the HotUpdater. This is useful for tracking update progress or other events during the update process.


For most use cases involving bundle download progress bar displays, it's more convenient to use the store hook instead of this listener. See [useHotUpdaterStore](./useHotUpdaterStore).


## Usage

Use `addEventListener` to subscribe to HotUpdater events. It returns an unsubscribe function to clean up the listener when it's no longer needed.

```tsx
const unsubscribe = HotUpdater.addListener("onProgress", ({ progress }) => {
  console.log(`Update progress: ${progress * 100}%`);
});

// Later, when you no longer need the listener
unsubscribe();
```

## Event Type

The `HotUpdaterEvent` type defines the available events and their corresponding payloads.

```typescript
export type HotUpdaterEvent = {
  onProgress: {
    progress: number;
  };
};
```

## Parameters

| Parameter   | Type                                  | Required | Description                                 |
|-------------|---------------------------------------|----------|---------------------------------------------|
| `eventName` | `keyof HotUpdaterEvent`                | âœ…        | The name of the event to listen for.          |
| `listener`  | `(event: HotUpdaterEvent[T]) => void` | âœ…        | The callback function to handle the event.    |

## Return Value

The `addEventListener` function returns a cleanup function that removes the event listener when called.

```typescript
const unsubscribe = HotUpdater.addListener("onProgress", ({ progress }) => {
  console.log(`Update progress: ${progress * 100}%`);
});

// Unsubscribe when done
unsubscribe();
```

## Example

Here's an example of how to use `addEventListener` in a React Native component:

```tsx
function App() {
  useEffect(() => {
    const unsubscribe = addListener("onProgress", ({ progress }) => {
      console.log(`Update progress: ${progress * 100}%`);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return (
    
      Hello World
    
  );
}

export default App;
```

---

# React Native API: "checkForUpdate"
URL: https://hot-updater.dev/docs/react-native-api/checkForUpdate
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/checkForUpdate.mdx

Check if updates are available

# `HotUpdater.checkForUpdate()`

The `checkForUpdate` function checks if there is an available update for the app by comparing the current app version and platform with the update server's bundle information.

This method is particularly useful when you need a custom update strategy without using the built-in `wrap` method.

## Usage

Use `checkForUpdate` to verify if an update bundle is available. You need to provide the source of the update server and optionally, request headers.

```tsx
async function checkForAppUpdate() {
  try {
    const updateInfo = await HotUpdater.checkForUpdate({
      source: getUpdateSource("", {
        updateStrategy: "appVersion", // or "fingerprint"
      }),
      requestHeaders: {
        Authorization: "Bearer ",
      },
    });

    if (!updateInfo) {
      return {
        status: "UP_TO_DATE",
      };
    }

    /**
     * You can apply updates using one of two methods:
     * 
     * Method 1: Use the updateBundle() method from the updateInfo object
     * - A convenience method built into the return value from checkForUpdate
     * - Performs the same function as HotUpdater.updateBundle with all required arguments pre-filled
     */
    await updateInfo.updateBundle();

    /**
     * Method 2: Call HotUpdater.updateBundle() directly
     * - Explicitly pass the necessary values extracted from updateInfo
     */
    // await HotUpdater.updateBundle({
    //   bundleId: updateInfo.id,
    //   fileUrl: updateInfo.fileUrl,
    //   status: updateInfo.status,
    // });

    if (updateInfo.shouldForceUpdate) {
      await HotUpdater.reload();
    }
    return updateInfo;
  } catch (error) {
    console.error("Failed to check for update:", error);
    return null;
  }
}

```

## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.

## Parameters

The `checkForUpdate` function accepts the following parameters:

| Parameter       | Type                | Required | Description                                      |
|-----------------|---------------------|----------|--------------------------------------------------|
| `source`        | `string`            | âœ…        | The URL of the update server.                     |
| `requestHeaders`| `Record` | âŒ        | Optional headers to include in the update request. |

## Return Value

The function returns an object of type `UpdateInfo` or `null` if the app is up to date.

```ts
export type UpdateStatus = "ROLLBACK" | "UPDATE";

export interface UpdateInfo {
  id: string;
  shouldForceUpdate: boolean;
  fileUrl: string | null;
  message: string | null;
  status: UpdateStatus;
}
```

### Example Return Value

```json
{
  "id": "01952bbd-e7b2-7931-aee8-2e2187caa0ce",
  "shouldForceUpdate": true,
  "status": "UPDATE",
  "fileUrl": "https://example.com/bundles/update.bundle",
  "message": "This is a test message",
}
```

---

# React Native API: "getChannel"
URL: https://hot-updater.dev/docs/react-native-api/getChannel
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/getChannel.mdx

Get the current update channel

# `HotUpdater.getChannel()`

The `HotUpdater.getChannel()` function retrieves the current release channel of the app. This is useful when you want to determine which channel updates are being applied from.

By default, if no channel is specified, the app is assigned to the `production` channel.

For more details about channels, refer to the [Channel Guide](/docs/guides/channel-management).

## Usage

You can use `HotUpdater.getChannel()` to dynamically check the release channel in your application logic.

### Example

```tsx
function App() {
  const channel = HotUpdater.getChannel();

  return (
    
      Current Channel: {channel}
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```

## Behavior

- If `releaseChannel` is set in `hot-updater.config.ts`, `HotUpdater.getChannel()` returns that value.
- If no channel is set, the default is `production`.
- Channels help separate environments such as `dev`, `staging`, and `production`, ensuring that updates are applied correctly.
- The initial channel is injected into the native app during the build process based on the `releaseChannel` specified in `hot-updater.config.ts`.
- After the app is built, updates can be deployed to the correct channel using `hot-updater deploy -c `, such as `hot-updater deploy -c production` or `hot-updater deploy -c dev`.
- **Important**: Channel changes require rebuilding the native app to take effect. Simply changing the channel in the configuration file or through deployment commands will not update the channel of an already built app.
- **It is crucial to set the correct channel during the initial build**, as the app will continue to receive updates only from that specified channel.

## Configuration Example (`hot-updater.config.ts`)

```tsx
import "dotenv/config";

export default defineConfig({
  releaseChannel: "dev", // Specifying the release channel
  build: ...,
  storage: ...,
  database: ...,
});
```

With this configuration, `HotUpdater.getChannel()` will return `"dev"`. This ensures that all future updates are correctly applied to the `dev` channel.

---

# React Native API: "isUpdateDownloaded"
URL: https://hot-updater.dev/docs/react-native-api/isUpdateDownloaded
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/isUpdateDownloaded.mdx

Check if update has been downloaded

# `HotUpdater.isUpdateDownloaded()`

Returns whether an update bundle has finished downloading in the current app session and is ready to be applied on reload.

- Returns `true` when the download `progress` has reached `1.0`.
- Returns `false` while downloading or before any download starts.
- Resets to `false` automatically when a new download starts.

## Usage

```tsx
async function maybeApplyUpdate() {
  if (HotUpdater.isUpdateDownloaded()) {
    await HotUpdater.reload();
  }
}
```

### Skip `checkForUpdate` when a download already exists

If a bundle has already finished downloading in this session, you can skip `checkForUpdate()` and just prompt the user to reload.

```tsx
async function checkAndUpdate() {
  // Avoid network call if an update is already downloaded and awaiting reload
  if (HotUpdater.isUpdateDownloaded()) {
    // e.g., show a "Restart to update" CTA or reload immediately
    return;
  }

  const updateInfo = await HotUpdater.checkForUpdate({
    source: getUpdateSource("", {
      updateStrategy: "appVersion", // or "fingerprint"
    }),
    // requestHeaders: { Authorization: "Bearer " },
  });

  if (!updateInfo) return;

  const ok = await updateInfo.updateBundle();
  if (!ok) return;

  if (updateInfo.shouldForceUpdate) {
    await HotUpdater.reload();
  }
}
```

## Details

- This value is derived from the internal `progress` state managed by `useHotUpdaterStore()`.
- It is session-scoped: it does not persist across app restarts.
- Use this when you need to decide whether to show a "Restart to update" UI or trigger a controlled reload.

```tsx
export function UpdateButton() {
  const { progress, isUpdateDownloaded } = useHotUpdaterStore();
  return (
     HotUpdater.reload()}
      disabled={!isUpdateDownloaded}
    />
  );
}
```

---

# React Native API: "reload"
URL: https://hot-updater.dev/docs/react-native-api/reload
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/reload.mdx

Reload the app with the updated bundle

# `HotUpdater.reload()`

By default, the `shouldForceUpdate` flag is `false`, the bundle is downloaded but not applied until the user restarts the app.

Calling `HotUpdater.reload()` reloads the app. If there is a completed update bundle ready to be applied, it will be applied immediately.


The `shouldForceUpdate` flag simply downloads the bundle and calls reload immediately.


## Usage

You can use it as shown below, but it is recommended to use it together with the `useHotUpdaterStore().progress value.

Refer to [useHotUpdaterStore()](./useHotUpdaterStore) for more information.


```tsx
function App() {
  const handleReload = () => {
    // Immediately reapply if there is a downloaded bundle
    await HotUpdater.reload(); // [!code hl]
  }

  return (
    
      Hello World

      
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```

---

# React Native API: "updateBundle"
URL: https://hot-updater.dev/docs/react-native-api/updateBundle
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/updateBundle.mdx

Download and install update bundles

# `HotUpdater.updateBundle()`

The `updateBundle` function downloads and applies a new update bundle to your React Native application. It uses the provided bundle information obtained from `checkForUpdate`.

This method is particularly useful when you need a custom update strategy without using the built-in `wrap` method.

## Usage

Use `updateBundle` to download and apply an available update by providing the bundle's unique identifier and the URL to the bundle file.

```tsx
async function applyAppUpdate(updateInfo: UpdateInfo) {
  try {
    const updateInfo = await HotUpdater.checkForUpdate({
      source: getUpdateSource("", {
        updateStrategy: "appVersion", // or "fingerprint"
      }),
      requestHeaders: {
        Authorization: "Bearer ",
      },
    });

    if (!updateInfo) {
      return {
        status: "UP_TO_DATE",
      };
    }

    /**
     * You can apply updates using one of two methods:
     *
     * Method 1: (RECOMMENDED) Use the updateBundle() method from the updateInfo object
     * - A convenience method built into the return value from checkForUpdate
     * - Automatically includes fileHash for secure verification
     * - All required arguments are pre-filled from the checkForUpdate response
     */
    await updateInfo.updateBundle();

    /**
     * Method 2: Call HotUpdater.updateBundle() directly
     * - Explicitly pass the necessary values extracted from updateInfo
     * - You must manually include fileHash for security
     */
    // await HotUpdater.updateBundle({
    //   bundleId: updateInfo.id,
    //   fileUrl: updateInfo.fileUrl,
    //   fileHash: updateInfo.fileHash,
    //   status: updateInfo.status,
    // });


    if (updateInfo.shouldForceUpdate) {
      await HotUpdater.reload();
    }

    console.log("Update applied successfully");
  } catch (error) {
    console.error("Failed to apply update:", error);
  }
}
```

## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.


## Parameters

The `updateBundle` function accepts the following parameters:

| Parameter | Type      | Required | Description                             |
|-----------|-----------|----------|-----------------------------------------|
| `id`      | `string`  | âœ…        | Unique identifier of the update bundle. |
| `fileUrl` | `string`  | âœ…        | URL from which the update bundle will be downloaded. |
| `fileHash` | `string \| null`  | âš ï¸ Optional but recommended | SHA256 hash of the bundle file for integrity verification. If provided, the downloaded file will be verified before extraction. |

### Behavior

- Downloads the specified bundle from the provided `fileUrl`.
- **If `fileHash` is provided**: Verifies the downloaded file's SHA256 hash before extraction. If verification fails, the update is aborted and the downloaded file is deleted.
- **If `fileHash` is not provided**: Proceeds with extraction without hash verification (not recommended for production).
- Applies the downloaded bundle as the active bundle for the application.
- Requires an explicit call to `HotUpdater.reload()` if you want to immediately reload the application after updating, particularly when `shouldForceUpdate` is true.

### Security Recommendation

**Always provide `fileHash` in production environments.** Hash verification protects against:
- Man-in-the-middle attacks
- Corrupted downloads
- Tampered bundle files

#### Recommended Approach

**Use `updateInfo.updateBundle()` instead of `HotUpdater.updateBundle()`** whenever possible. The `updateInfo.updateBundle()` method automatically includes the `fileHash` from the `checkForUpdate()` response, ensuring secure verification without manual parameter passing.

```tsx
// âœ… Recommended: fileHash is automatically included
const updateInfo = await checkForUpdate(/* ... */);
await updateInfo.updateBundle();

// âš ï¸ Less safe: you must remember to include fileHash manually
await HotUpdater.updateBundle({
  bundleId: updateInfo.id,
  fileUrl: updateInfo.fileUrl,
  fileHash: updateInfo.fileHash, // Easy to forget!
  status: updateInfo.status,
});
```

The `fileHash` is automatically included in the response from `checkForUpdate()` when your update server provides it.

---

# React Native API: "useHotUpdaterStore"
URL: https://hot-updater.dev/docs/react-native-api/useHotUpdaterStore
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/useHotUpdaterStore.mdx

React hook for accessing update state

# `useHotUpdaterStore()`

A store related to updates.

## Download Progress

`progress` is a number representing the bundle download progress. It has a value between 0 and 1.

When `isUpdateDownloaded` is `true`, it means the bundle download is complete and the update will be applied when `HotUpdater.reload()` is called. The `isUpdateDownloaded` becomes `true` when the `progress` value reaches 1.

```tsx
function App() {
  const { progress, isUpdateDownloaded } = useHotUpdaterStore();

  return (
    
      Hello World
      {Math.round(progress * 100)}%
       HotUpdater.reload()}
        disabled={!isUpdateDownloaded}
      />
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    Authorization: "Bearer ",
  },
})(App);
```

## Optimizing Renders with Selectors

You can optimize your component renders by using selectors to subscribe only to specific parts of the state. This prevents unnecessary re-renders when other parts of the state change.

```tsx
function ProgressDisplay() {
  // Only re-renders when progress changes
  const progress = useHotUpdaterStore(state => state.progress);

  return {Math.round(progress * 100)}%;
}

function UpdateButton() {
  // Only re-renders when isUpdateDownloaded changes
  const isUpdateDownloaded = useHotUpdaterStore(state => state.isUpdateDownloaded);

  return (
     HotUpdater.reload()}
      disabled={!isUpdateDownloaded}
    />
  );
}
```

---

# React Native API: "wrap"
URL: https://hot-updater.dev/docs/react-native-api/wrap
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/wrap.mdx

Wrap your app component to enable hot updates

# `HotUpdater.wrap()`

`HotUpdater.wrap` checks for updates at the entry point, and if there is a bundle to update, it downloads the bundle and applies the update strategy.

## Usage
Use the `source` option in `HotUpdater.wrap` to specify the update server URL, then wrap the App entry point.

Since it uses fetch, if you need to pass headers along with it, you can use the `requestHeaders` option to pass headers.
```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({ // [!code hl:10]
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```


## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.


## Fallback Component

During an update check, access to the entry point is temporarily blocked while communicating with the server.

- If the update is **force update**, the entry point remains blocked, and the progress updates as the bundle downloads.  
- If **not force update**, the entry point is only blocked during the update check.

Without a `fallbackComponent`, the bundle downloads without blocking the screen.

### `fallbackComponent` Props:
- **`progress`**: Download progress (e.g., for a progress bar).  
- **`status`**: Update state:
  - `CHECK_FOR_UPDATE`: Checking for updates.  
  - `UPDATING`: Downloading the new bundle.  

Using these props, you can ensure a smooth UI transition.  
It is also recommended to include a **splash image** for a better user experience.
```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({ // [!code hl:26]
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  fallbackComponent: ({ progress, status, message }) => (
      
        {/* You can put a splash image here. */}

        
          {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
        
        {message && (
          
            {message}
          
        )}
        {progress > 0 ? (
          
            {Math.round(progress * 100)}%
          
        ) : null}
      
    ),
  })(App);
```

## `reloadOnForceUpdate`

When a force update bundle is downloaded, the app will automatically reload. If `false`, `shouldForceUpdate` will be returned as `true` in `onUpdateProcessCompleted` but the app won't reload. default is `true`.

### `reloadOnForceUpdate` is `true`

When a force update exists, the app will automatically reload.

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  reloadOnForceUpdate: true, // Automatically reload the app on force updates // [!code hl]
})(App);
```


### `reloadOnForceUpdate` is `false`

When a force update exists, the app will not reload. `shouldForceUpdate` will be returned as `true` in `onUpdateProcessCompleted`.

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  reloadOnForceUpdate: false, // The app won't reload on force updates // [!code hl]
  onUpdateProcessCompleted: ({ status, shouldForceUpdate, id, message }) => {  // [!code hl]
    console.log("Bundle updated:", status, shouldForceUpdate, id, message);  // [!code hl]
    if (shouldForceUpdate) { // [!code hl]
      await HotUpdater.reload(); // [!code hl]
    } // [!code hl]
  },  // [!code hl]
})(App);
```

## onUpdateProcessCompleted

The `onUpdateProcessCompleted` option allows you to perform additional actions after the update process is completed.

### Callback Arguments

| Property | Type | Description |
|----------|-------------|-------------|
| `status` | "ROLLBACK" \| "UPDATE" \| "UP_TO_DATE" | The status of the update process |
| `shouldForceUpdate` | boolean | Whether the update process is forced |
| `id` | string | The ID of the bundle to update |
| `message` | string | The message of the update process |

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  onUpdateProcessCompleted: ({ status, shouldForceUpdate, id, message }) => {
    console.log("Bundle updated:", status, shouldForceUpdate, id, message);
  },

  // If you need to show the progress while downloading the new bundle, you can use the `onProgress` option.
  onProgress: ({ progress }) => {
    console.log("Bundle downloading progress:", progress);
  },
})(App);
```

## Update Strategy

| Update Type   | When Applied                                              | How to Enable                              |
|---------------|----------------------------------------------------------|-------------------------------------------|
| Default       | Downloads the update bundle in the background and applies it when the user restarts the app. | Default setting                           |
| Force Update  | Downloads the update bundle and applies it immediately.   | Use the `--force-update` flag or console. |


## Custom source Function

You can pass an async function to the source option for full control over how update info is fetched.

```tsx
export default HotUpdater.wrap({
  source: async () => {
    const res = await fetch("https://your.api/update-info");
    return (await res.json()) as AppUpdateInfo | null;
  },
  // ... other options
});
```

---

# Self-Hosted: "Self-Hosted Overview"
URL: https://hot-updater.dev/docs/self-hosted/overview
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/self-hosted/overview.mdx

Overview of self-hosted hot-updater deployment

# Self-Hosted Overview

TODO: Document self-hosted deployment

## Topics to Cover

- Self-hosted architecture
- Requirements
- Deployment options

---

# Self-Hosted: "Self-Hosted Provider"
URL: https://hot-updater.dev/docs/self-hosted/setup
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/self-hosted/setup.mdx

Deploy hot-updater on your own infrastructure

# Self-Hosted Provider

Coming Soon

---

# Storage Plugins: "AWS S3 Storage"
URL: https://hot-updater.dev/docs/storage-plugins/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/aws.mdx

Use aws storage with hot-updater

# AWS S3 Storage

TODO: Document aws storage integration

---

# Storage Plugins: "Cloudflare R2 Storage"
URL: https://hot-updater.dev/docs/storage-plugins/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/cloudflare.mdx

Use Cloudflare R2 storage with hot-updater

# Cloudflare R2 Storage

TODO: Document cloudflare storage integration

---

# Storage Plugins: "Firebase Storage"
URL: https://hot-updater.dev/docs/storage-plugins/firebase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/firebase.mdx

Use Firebase Storage with hot-updater

# Firebase Storage Plugin

TODO: Document firebase storage integration

---

# Storage Plugins: "Supabase Storage"
URL: https://hot-updater.dev/docs/storage-plugins/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/supabase.mdx

Use Supabase storage with hot-updater

# Supabase Storage

TODO: Document supabase storage integration

---

