# Hot Updater - Complete Documentation

This file contains the full documentation for Hot Updater, a self-hostable OTA updates solution for React Native apps.

---

# Build Plugins: "Bare (CLI) Plugin"
URL: https://hot-updater.dev/docs/build-plugins/bare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/bare.mdx

Build plugin for React Native CLI projects (non-Expo). Bundles your React Native app using the Metro bundler.

## Installation

```package-install
npm install @hot-updater/bare --save-dev
```

## Configuration

```typescript
interface BarePluginConfig {
  outDir?: string;           // Output directory (default: "dist")
  entryFile?: string;        // Entry file (default: "index.js")
  sourcemap?: boolean;       // Generate sourcemaps (default: false)
  enableHermes: boolean;     // Use Hermes compiler (required)
}
```

## Usage

```typescript
export default defineConfig({
  build: bare({
    enableHermes: true,
    sourcemap: false,
    entryFile: 'index.js'
  }),
  // ... other config
});
```

## Babel Configuration

Add the Hot Updater Babel plugin to your `babel.config.js`:

```javascript
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: ['@hot-updater/babel-plugin'],
};
```

## Key Features

- Uses React Native CLI's Metro bundler
- Automatic Hermes bytecode compilation when enabled
- Minification handled by Hermes (disabled when Hermes is enabled)
- Supports custom entry files and output directories

---

# Build Plugins: "Expo Plugin"
URL: https://hot-updater.dev/docs/build-plugins/expo
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/expo.mdx

Build plugin for Expo projects. Bundles your Expo app using Expo's native export command.

## Installation

```package-install
npm install @hot-updater/expo --save-dev
```

## Configuration

```typescript
interface ExpoPluginConfig {
  outDir?: string;      // Output directory (default: "dist")
  sourcemap?: boolean;  // Generate sourcemaps (default: false)
}
```

## Usage

```typescript
export default defineConfig({
  build: expo({
    sourcemap: false
  }),
  // ... other config
});
```

## Expo Configuration

Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native", // [!code ++]
        { // [!code ++]
          "channel": "production" // [!code ++]
        } // [!code ++]
      ] // [!code ++]
    ]
  }
}
```

Run prebuild to apply the changes:

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```

## Key Features

- Uses Expo's `expo export:embed` command
- Auto-detects Hermes from app.json configuration
- Supports both managed and bare Expo workflows
- Compatible with Expo prebuild for native builds
- Automatically configures bundler based on Expo settings

---

# Build Plugins: "Rock Plugin"
URL: https://hot-updater.dev/docs/build-plugins/rock
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/build-plugins/rock.mdx

Build plugin for projects using [Rock](https://www.rockjs.dev/) framework, a React Native framework created by Callstack.

## Installation

```package-install
npm install @hot-updater/rock --save-dev
```

## Configuration

```typescript
interface RockPluginConfig {
  outDir?: string;      // Output directory (default: "dist")
  entryFile?: string;   // Entry file (default: "index.js")
  sourcemap?: boolean;  // Generate sourcemaps (default: false)
  hermes?: boolean;     // Use Hermes compiler (default: true)
}
```

## Usage

```typescript
export default defineConfig({
  build: rock({
    hermes: true,
    entryFile: 'index.js',
    sourcemap: false
  }),
  // ... other config
});
```

## Re.Pack Integration (Recommended)

Rock framework uses [Re.Pack](https://re-pack.dev/) bundler. It's recommended to use the Re.Pack plugin to set bundle ID at build time.

Install the Re.Pack plugin:

```package-install
npm install @hot-updater/repack --save-dev
```

Add the plugin to your `rspack.config.mjs`:

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```

See the [Re.Pack integration documentation](/docs/integration-plugins/repack) for more details.

## Key Features

- Build plugin for [Rock framework](https://www.rockjs.dev/)
- Supports Hermes compilation
- Configurable output directory and entry files

---

# Concepts: "How does it work?"
URL: https://hot-updater.dev/docs/concepts/how-it-works
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/concepts/how-it-works.mdx

Understanding the core infrastructure and update decision logic

## Core Infrastructure

`hot-updater` consists of three key components:

- **Storage**: A place where JavaScript bundles are stored, supporting AWS S3, Cloudflare R2, Supabase Storage, Firebase Storage, etc.
- **Database**: Stores metadata about deployed bundles (version information, etc.) and manages update information.
- **Server**: Determines whether updates are required based on the app's current state, operating through AWS Lambda@Edge, Cloudflare Workers, Supabase Edge Functions, or Firebase Cloud Functions.

Storage and Database are configured using plugins defined in `hot-updater.config.ts`. The Server is initialized and deployed using the `hot-updater init` command.

## Update Decision Logic

`hot-updater` primarily uses UUIDv7 for its operations, with the following update determination process:

### 1. Bundle ID Generation and Management
- Running `hot-updater deploy` invokes a Babel plugin to generate a UUIDv7-formatted Bundle ID.
- This Bundle ID includes the deployment timestamp and is uniquely generated per bundle.

### 2. Initial Native App Build
- The first version of the native app does not have an initial Bundle ID, as it isn't created by `hot-updater deploy` but by the native build process.
- In this case, a minimal Bundle ID (`minBundleId`) in UUIDv7 format, based on the app build timestamp, is used.

### 3. Communication with the Update Server
- The app communicates with the server using the current Bundle ID to verify if the bundle is activated (`enabled=true`).
- If the bundle isn't active, the app forcibly updates (rollbacks) to a previously active bundle.
- If an active bundle newer than the current app version exists, the app updates to the latest available bundle.

### 4. Usage of minBundleId
- The `minBundleId` is determined based on the native app's build timestamp.
- The existence of a native app build ensures the embedded bundle is the latest at that point. Bundles older than the `minBundleId` are ignored.
- Every new deployment generates a new Bundle ID, ensuring accurate and reliable updates.

---

# Concepts: "Plugin System"
URL: https://hot-updater.dev/docs/concepts/plugin-system
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/concepts/plugin-system.mdx

"Hot Updater uses a flexible plugin system that lets you customize how bundles are built, stored, and managed to fit your infrastructure."

## Build Plugin

Build plugins handle the bundling process when you run the `hot-updater deploy` command. They generate the JavaScript bundles for your updates.

### Supported Plugins

- **`@hot-updater/bare`**: Executes the bundle command through React Native CLI. Bundles through Metro or Re.Pack.
- **`@hot-updater/rock`**: Executes the bundle command through [Rock](https://github.com/callstack/rock)(Formerly RNEF).
- **`@hot-updater/expo`**: Executes the bundle command through Expo.

## Storage Plugin

Storage plugins upload your generated bundles during the `hot-updater deploy` command and store them in your chosen storage provider.

### Supported Plugins

- **`@hot-updater/supabase`**: Provides `supabaseStorage` functionality, leveraging Supabase for storage.
- **`@hot-updater/cloudflare`**: Provides `r2Storage` functionality, leveraging Cloudflare R2 for storage.
- **`@hot-updater/aws`**: Provides `s3Storage` functionality, enabling the use of AWS S3 for storage.
- **`@hot-updater/firebase`**: Provides `firebaseStorage` functionality, utilizing Firebase Storage for storing update bundles.

## Database Plugin

Database plugins store bundle metadata that your app uses to check for updates. They run during the `hot-updater deploy` command.

### Supported Plugins

- **`@hot-updater/supabase`**: Provides `supabaseDatabase` functionality, using Supabase as a database solution.
- **`@hot-updater/aws`**: Provides `s3Database` functionality, utilizing AWS for database storage.
- **`@hot-updater/cloudflare`**: Provides `d1Database` functionality, leveraging Cloudflare D1 for database storage.
- **`@hot-updater/firebase`**: Provides `firebaseDatabase` functionality, using Firebase Firestore for storing update metadata.

---

# Database Plugins: "AWS S3 Database"
URL: https://hot-updater.dev/docs/database-plugins/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/aws.mdx

Store your Hot Updater bundle metadata as JSON files in S3, served via CloudFront CDN.

## Installation

```package-install
npm install @hot-updater/aws --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [AWS](/docs/managed-providers/aws) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface S3DatabaseConfig {
  region: string;                    // AWS region
  bucketName: string;                // S3 bucket for metadata
  cloudfrontDistributionId: string;  // CloudFront distribution ID
  apiBasePath?: string;              // API path (default: "/api/check-update")
  credentials?: {
    accessKeyId: string;
    secretAccessKey: string;
  };
}
```

## Usage

```typescript
export default defineConfig({
  database: s3Database({
    region: 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    },
    bucketName: 'my-metadata-bucket',
    cloudfrontDistributionId: process.env.CLOUDFRONT_DISTRIBUTION_ID
  }),
  // ... other config
});
```

## Complete Example

Combined storage and database:

```typescript
export default defineConfig({
  storage: s3Storage({
    region: 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    },
    bucketName: 'my-bundles-bucket'
  }),
  database: s3Database({
    region: 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    },
    bucketName: 'my-metadata-bucket',
    cloudfrontDistributionId: process.env.CLOUDFRONT_DISTRIBUTION_ID
  }),
  // ... other config
});
```

---

# Database Plugins: "Cloudflare D1 Database"
URL: https://hot-updater.dev/docs/database-plugins/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/cloudflare.mdx

Store your Hot Updater bundle metadata in Cloudflare D1, a serverless SQLite database running at the edge.

## Installation

```package-install
npm install @hot-updater/cloudflare --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Cloudflare](/docs/managed-providers/cloudflare) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface D1DatabaseConfig {
  databaseId: string;           // D1 database ID
  accountId: string;            // Cloudflare account ID
  cloudflareApiToken: string;   // Cloudflare API token
}
```

## Usage

```typescript
export default defineConfig({
  database: d1Database({
    databaseId: process.env.D1_DATABASE_ID,
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID,
    cloudflareApiToken: process.env.CLOUDFLARE_API_TOKEN
  }),
  // ... other config
});
```

## Complete Example

Combined R2 storage and D1 database:

```typescript
export default defineConfig({
  storage: s3Storage({
    region: 'auto',
    endpoint: `https://${process.env.CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId: process.env.R2_ACCESS_KEY_ID,
      secretAccessKey: process.env.R2_SECRET_ACCESS_KEY
    },
    bucketName: 'my-r2-bucket'
  }),
  database: d1Database({
    databaseId: process.env.D1_DATABASE_ID,
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID,
    cloudflareApiToken: process.env.CLOUDFLARE_API_TOKEN
  }),
  // ... other config
});
```

---

# Database Plugins: "Firestore Database"
URL: https://hot-updater.dev/docs/database-plugins/firestore
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/firestore.mdx

Store your Hot Updater bundle metadata in Cloud Firestore, Firebase's NoSQL document database.

## Installation

```package-install
npm install @hot-updater/firebase firebase-admin --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Firebase](/docs/managed-providers/firebase) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface FirebaseDatabaseConfig {
  projectId: string;               // Firebase project ID
  credential: admin.credential.Credential;  // Firebase credential
}
```

## Environment Variables

Set up your Firebase credentials:

```bash title=".env.hotupdater"
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=/path/to/your-service-account-key.json
FIREBASE_PROJECT_ID=your-project-id
```

## Usage

```typescript
// https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments
// Check your .env file and add the credentials
// Set the GOOGLE_APPLICATION_CREDENTIALS environment variable to your credentials file path
// Example: GOOGLE_APPLICATION_CREDENTIALS=./firebase-adminsdk-credentials.json
const credential = admin.credential.applicationDefault();

export default defineConfig({
  database: firebaseDatabase({
    projectId: process.env.FIREBASE_PROJECT_ID,
    credential
  }),
  // ... other config
});
```

## Complete Example

Combined storage and database:

```typescript
const credential = admin.credential.applicationDefault();

export default defineConfig({
  storage: firebaseStorage({
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    credential
  }),
  database: firebaseDatabase({
    projectId: process.env.FIREBASE_PROJECT_ID,
    credential
  }),
  // ... other config
});
```

## Dependencies

Requires `firebase-admin` as a peer dependency:

```package-install
npm install firebase-admin --save-dev
```

---

# Database Plugins: "Standalone Database"
URL: https://hot-updater.dev/docs/database-plugins/standalone
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/standalone.mdx

Store your Hot Updater bundle metadata in your custom self-hosted database by implementing HTTP API endpoints.

## Installation

```package-install
npm install @hot-updater/standalone --save-dev
```

## Configuration

```typescript
interface StandaloneRepositoryConfig {
  baseUrl: string;                        // Your API base URL
  commonHeaders?: Record; // Headers sent with all requests
  routes?: Routes;                        // Optional custom route configuration
}

interface Routes {
  upsert: () => RouteConfig;
  list: () => RouteConfig;
  retrieve: (bundleId: string) => RouteConfig;
  delete: (bundleId: string) => RouteConfig;
}
```

## Usage

```typescript
export default defineConfig({
  database: standaloneRepository({
    baseUrl: process.env.DATABASE_API_URL,
    commonHeaders: {
      'Authorization': `Bearer ${process.env.API_TOKEN}`
    }
  }),
  // ... other config
});
```

## API Endpoints

Your backend must implement these endpoints:

### POST /bundles
Create or update bundle(s).

**Request:**
- Method: `POST`
- Content-Type: `application/json`
- Body: Array of bundle objects

**Response:**
```json
{
  "success": true
}
```

### GET /bundles
List all bundles (with optional filtering).

**Request:**
- Method: `GET`
- Headers: `Cache-Control: no-cache`

**Response:**
```json
[
  {
    "id": "bundle-id",
    "channel": "production",
    "platform": "ios",
    // ... other bundle fields
  }
]
```

### GET /bundles/:bundleId
Retrieve a specific bundle by ID.

**Request:**
- Method: `GET`
- Headers: `Accept: application/json`

**Response:**
```json
{
  "id": "bundle-id",
  "channel": "production",
  // ... bundle fields
}
```

### DELETE /bundles/:bundleId
Delete a specific bundle.

**Request:**
- Method: `DELETE`

**Response:** 200 OK or 404 Not Found

## Custom Routes

You can customize the endpoint paths and headers:

```typescript
standaloneRepository({
  baseUrl: 'https://api.example.com',
  routes: {
    upsert: () => ({
      path: '/v1/metadata/bundles',
      headers: { 'X-Custom-Header': 'value' }
    }),
    list: () => ({
      path: '/v1/metadata/bundles',
      headers: { 'Cache-Control': 'no-store' }
    }),
    retrieve: (bundleId) => ({
      path: `/v1/metadata/bundles/${bundleId}`,
      headers: { 'Accept': 'application/json' }
    }),
    delete: (bundleId) => ({
      path: `/v1/metadata/bundles/${bundleId}`
    })
  }
})
```

## Bundle Object Schema

Your API should handle bundle objects with these fields:
- `id` - Unique bundle identifier
- `channel` - Deployment channel (e.g., "production", "staging")
- `platform` - Platform ("ios" or "android")
- `storageUri` - URI where bundle files are stored
- `createdAt` - Timestamp
- Other metadata fields

## Complete Example

Combined standalone storage and database:

```typescript
export default defineConfig({
  storage: standaloneStorage({
    baseUrl: process.env.STORAGE_API_URL,
    commonHeaders: {
      'Authorization': `Bearer ${process.env.API_TOKEN}`
    }
  }),
  database: standaloneRepository({
    baseUrl: process.env.DATABASE_API_URL,
    commonHeaders: {
      'Authorization': `Bearer ${process.env.API_TOKEN}`
    }
  }),
  // ... other config
});
```

---

# Database Plugins: "Supabase Database"
URL: https://hot-updater.dev/docs/database-plugins/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/database-plugins/supabase.mdx

Store your Hot Updater bundle metadata in Supabase PostgreSQL database.

## Installation

```package-install
npm install @hot-updater/supabase --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Supabase](/docs/managed-providers/supabase) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface SupabaseDatabaseConfig {
  supabaseUrl: string;       // Your Supabase project URL
  supabaseAnonKey: string;   // Your Supabase anon/public key
}
```

## Usage

```typescript
export default defineConfig({
  database: supabaseDatabase({
    supabaseUrl: process.env.SUPABASE_URL,
    supabaseAnonKey: process.env.SUPABASE_ANON_KEY
  }),
  // ... other config
});
```

## Complete Example

Combined storage and database:

```typescript
export default defineConfig({
  storage: supabaseStorage({
    supabaseUrl: process.env.SUPABASE_URL,
    supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
    bucketName: 'hot-updater-bundles'
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.SUPABASE_URL,
    supabaseAnonKey: process.env.SUPABASE_ANON_KEY
  }),
  // ... other config
});
```

---

# Get Started: "Basic Usage"
URL: https://hot-updater.dev/docs/get-started/basic-usage
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/get-started/basic-usage.mdx

"This guide walks you through the essential steps to integrate hot-updater into your React Native project."

## Provider Setup

Before configuring the build plugin, you need to set up a provider to handle updates. Hot-updater supports multiple managed providers that handle storage and update distribution.

### Step 1: Install hot-updater

First, install the hot-updater package:

```package-install
npm install hot-updater --save-dev
```

### Step 2: Initialize Your Provider

Run the initialization command to set up your provider interactively:

```package-install
npx hot-updater init
```

This interactive CLI will guide you through:

1. **Build Plugin Selection**: Choose your build system (Bare/React Native CLI, Re.Pack, or Expo)
2. **Provider Selection**: Select from available providers:
   - [Supabase](/docs/managed-providers/supabase)
   - [Firebase](/docs/managed-providers/firebase)
   - [Cloudflare](/docs/managed-providers/cloudflare)
   - [AWS](/docs/managed-providers/aws)

3. **Provider Configuration**: Follow provider-specific prompts for authentication and resource setup.

### Step 3: Generated Configuration

After initialization, two files will be generated:

**`.env.hotupdater`** - Contains provider credentials and configuration:

```
# Example for Supabase
HOT_UPDATER_SUPABASE_URL=https://your-project.supabase.co
HOT_UPDATER_SUPABASE_ANON_KEY=your-anon-key
HOT_UPDATER_SUPABASE_BUCKET_NAME=your-bucket-name
```

**`hot-updater.config.ts`** - Contains provider integration settings:

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});
```


For detailed provider-specific setup instructions, see the [Managed Providers](/docs/managed-providers/supabase) documentation.



The environment variables in `.env` are used only during deployment, not in your app bundle. However, if you're using `react-native-dotenv`, review the [Security guidelines](/docs/policy/security#plugin-token-protection).


### Step 4: Wrap Your Application

Add the HotUpdater wrapper to your main application component:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server-url/api/check-update", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  requestHeaders: {
    // Optional: Add custom headers if needed
  },
  fallbackComponent: ({ progress, status }) => (
    
      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);
```


The update server URL will be provided after running `npx hot-updater init`. Check your terminal output or provider console for the correct URL.


## Plugin Configuration

Configure the build plugin to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```

  
  

First, install the Re.Pack plugin:

```package-install
npm install @hot-updater/repack --save-dev
```

Then add the following to your `rspack.config.mjs` file:

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```

  
  

Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

Run prebuild to apply the changes:

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


For Expo projects, the plugin automatically generates the native code configuration described in the next section.


  


## Native Code Setup

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.


If you're using Expo with the plugin configured above, this step is handled automatically during prebuild.


### Android


  

For React Native 0.82 and above, modify your `MainApplication.kt`:

```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.hotupdater.HotUpdater

class MainApplication : Application(), ReactApplication {

  override val reactHost: ReactHost by lazy {
    getDefaultReactHost(
      context = applicationContext,
      packageList =
        PackageList(this).packages.apply {
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // add(MyReactNativePackage())
        },
      jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
    )
  }

  override fun onCreate() {
    super.onCreate()
    loadReactNative(this)
  }
}
```

  
  

For React Native versions below 0.82, modify your `MainApplication.kt`:

```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```

  
  

For Java-based projects, modify your `MainApplication.java`:

```java title="android/app/src/main/java/com//MainApplication.java"
package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}
```

  


### iOS


  

For Swift projects, modify your `AppDelegate.swift`:

```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}
```

  
  

For Objective-C projects, modify your `AppDelegate.mm`:

```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```

  


## Next Steps

Now that you've completed the setup, you can start deploying updates:

### Deploy Your First Update

Build and publish an update to your users:

```package-install
npx hot-updater deploy
```

Use the interactive mode for guided deployment:

```package-install
npx hot-updater deploy -i
```

For emergency updates with forced reload:

```package-install
npx hot-updater deploy -i -f
```

### Monitor and Manage Updates

Open the console to track deployments, manage versions, and perform rollbacks:

```package-install
npx hot-updater console
```

### Explore Advanced Features

Learn more about advanced capabilities:

- [Update Strategies](/docs/guides/update-strategies) - Choose between app version and fingerprint strategies
- [Channel Management](/docs/guides/channel-management) - Manage multiple environments and user groups
- [Simulator Testing](/docs/guides/simulator-test) - Test updates in release mode before production
- [Security Best Practices](/docs/policy/security) - Secure your update infrastructure

---

# Get Started: "Introduction"
URL: https://hot-updater.dev/docs/get-started/introduction
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/get-started/introduction.mdx

"Self-hostable OTA update solution for React Native apps, alternative to CodePush."

## What is Hot Updater?

Hot Updater is a self-hostable OTA (Over-The-Air) update solution for React Native apps. Deploy JavaScript bundle updates instantly without going through app stores.

## Why Hot Updater?

CodePush depended on Microsoft's AppCenter, which had limitations:
- No CDN support, causing slow downloads in some regions
- Only supports Metro bundler, excluding newer alternatives like Re.Pack
- AppCenter has been discontinued

Hot Updater solves these problems with two core principles:

**1. Deploy Anywhere**
Use any infrastructure you want - AWS, Cloudflare, Supabase, Firebase, or your own servers.

**2. Use Any Bundler**
Works with Metro, Re.Pack or any bundler through the plugin system.

## How It Works

Hot Updater uses a [Plugin System](../concepts/plugin-system) that separates concerns:
- **Build Plugins**: Handle bundling (Metro, Re.Pack, Expo, Rock)
- **Storage Plugins**: Store bundles anywhere (S3, R2, Supabase, Firebase)
- **Database Plugins**: Manage metadata (PostgreSQL, D1, Firestore)

This architecture gives you complete control over your deployment infrastructure.

## Key Features

- **Self-Hosting**: Full control over your update infrastructure
- **Multi-Platform**: Seamless iOS and Android support
- **Web Console**: Intuitive update management interface
- **Version Control**: Robust versioning with semantic versioning support
- **Forced Updates**: Push critical updates when needed
- **Channel Management**: Separate environments (dev, staging, production)
- **Fingerprint Strategy**: Automatic native compatibility checking

---

# Guides: "Channels"
URL: https://hot-updater.dev/docs/guides/channel-management
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/channel-management.mdx

"Channels let you manage updates across different environments (development, staging, production) and target specific user groups or separate applications."

## Overview

Channels work for both environment management and multi-app scenarios. You can use them to separate environments like dev, staging, and production, or to manage completely different apps (e.g., app2, app3, app4) with their own channels.

- **Default Channel**: Apps use the `production` channel when no channel is specified.
- **Environment Management**: Separate your environments (`dev`, `staging`, `production`) to control which updates go where.

## Setting Up Channels

### 1. Specify Channel in Configuration File


  
    Use the `hot-updater channel set` command to specify your desired channel.

    ```package-install
    npx hot-updater channel set 
    ```

    This command will modify the native project files for you. Here's what changes:

    
      
      ```tsx title="ios/HotUpdaterExample/Info.plist"
      HOT_UPDATER_CHANNEL // [!code ++]
      your_set_channel // [!code ++]
      ```
      

      
      ```xml title="android/app/src/main/res/values/strings.xml"
      
          HotUpdaterExample
           // [!code ++]
          your_set_channel
      
      ```
      
    
  
  
    For Expo, you need to add the channel to the plugin configuration in your `app.json` file.

    ```json title="app.json"
    {
      "expo": {
        "plugins": [
          [
            "@hot-updater/react-native",
            {
              "channel": ""
            }
          ]
        ]
      }
    }
    ```
    Replace `` with your desired channel (e.g., `production`).

    After modifying `app.json`, run `prebuild` to apply the changes to the native projects.

    ```package-install
    npx expo prebuild --clean
    ```
  


## Custom Configuration Paths

For projects with non-standard structures or iOS app extensions, you can configure custom paths for platform-specific configuration files in your `hot-updater.config.ts`:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  // ... other configurations
  platform: {
    ios: {
      infoPlistPaths: [
        "ios/YourApp/Info.plist",
        "ios/YourAppExtension/Info.plist", // Include extension Info.plist
        "ios/NotificationService/Info.plist"
      ]
    },
    android: {
      stringResourcePaths: [
        "android/app/src/main/res/values/strings.xml",
        "android/app/src/debug/res/values/strings.xml" // Include additional resource files
      ]
    }
  }
});
```

This is useful when:
- Your iOS project has app extensions (widgets, share extensions, notification services)
- You have multiple Android build variants with different resource paths
- Your project doesn't follow the standard React Native file structure

**Important**: Configure these custom paths before running `hot-updater channel set` commands to ensure all relevant files are updated with the new channel.

### 2. Rebuild App with New Channel

After setting the channel, rebuild your app in Release mode:


  
    **iOS:**
    ```sh
    cd ios && pod install && cd ..
    npx react-native run-ios --mode Release
    ```

    **Android:**
    ```sh
    npx react-native run-android --mode Release
    ```
  
  
    **iOS:**
    ```sh
    npx rock run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx rock run:android --variant Release
    ```
  
  
    **iOS:**
    ```sh
    npx expo run:ios --variant release
    ```

    **Android:**
    ```sh
    npx expo run:android --variant release
    ```
  


### 3. Specify Channel Deployment

You can also specify the target channel directly during deployment:

```package-install
npx hot-updater deploy -p  -c ""
```

Replace `` with your target channel name (e.g., `dev`, `staging`, `production`).

## Retrieving the Current Channel

Use the `HotUpdater.getChannel()` function to retrieve the current release channel within your app.
We recommend displaying this value in your app UI to visually confirm that it's using the intended update channel.

### Example Usage

```tsx
function App() {
  const channel = HotUpdater.getChannel();

  return (
    
      Current Channel: {channel}
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
})(App);
```

## Channel Behavior

- Defaults to `production` if no channel is specified.
- Channels ensure separation of different environments (e.g., `dev`, `staging`, `production`) to apply updates accurately.
- Updates can subsequently be deployed using `hot-updater deploy -c `.
- **Important**: Changing the channel requires rebuilding the native app; simply altering the configuration file or deployment commands will not affect an already built app.

---

# Guides: "Compression Strategy"
URL: https://hot-updater.dev/docs/guides/compression
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/compression.mdx

"Choose a compression format for your bundle distribution."

## Supported Formats

- **`zip`** - Standard ZIP format (DEFLATE algorithm). Fast compression and decompression.
- **`tar.gz`** - TAR archive with GZIP compression (LZ77 algorithm). ~10-15% smaller than ZIP.
- **`tar.br`** - TAR archive with [Brotli](https://github.com/google/brotli) compression. ~20-30% smaller than GZIP. Developed by Google for web compression.

## Configuration

Set `compressStrategy` in your `hot-updater.config.ts`:

```ts
export default defineConfig({
  // ... other options
  compressStrategy: 'tar.gz', // 'zip' | 'tar.gz' | 'tar.br'
});
```

## Usage

After setting the compression strategy, deploy your bundle:

```bash
npx hot-updater deploy -p ios
npx hot-updater deploy -p android
```

The bundle will be compressed and deployed using the specified format.

**How it works:**
- The client app automatically detects the compression format (ZIP, GZIP, or Brotli) and decompresses accordingly
- Users download the compressed bundle, reducing bandwidth usage
- Choose a format with better compression ratio to minimize download size and save users' data


Since the client handles all formats transparently, choose the format with the best compression ratio (`tar.br` or `tar.gz`) to reduce download sizes for your users.

---

# Guides: "Console (Rollback & Force Update)"
URL: https://hot-updater.dev/docs/guides/console
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/console.mdx

"Opens a localhost server based on plugins configured in `hot-updater.config.ts`. For security reasons, only localhost server is supported at the moment."

**The console provides the following features:**
- Rollback
- Force update flag
- Quick access to git history for updates



## Configuration (Optional)

This is a console configuration that does not affect the bundle.

You can configure additional console settings in the `hot-updater.config.ts` file.

The `storage` and `database` plugins must be exist.

| Option | Description | Default |
| --- | --- | --- |
| `console.gitUrl` | Enables commit shortcuts by linking to git commit hashes | - |
| `console.port` | Sets the console server port | `1422` |

```ts title="hot-updater.config.ts"
export default defineConfig({
  console: { // [!code hl]
    port: 3000, // [!code hl]
  }, // [!code hl]
  build: ...,
  storage: ...,
  database: ...,
});

```

## Usage
Execute the following command:

```package-install
npx hot-updater console
```



## Rollback

When you set a bundle's `enabled` status to `false` in the console, users who have that bundle will immediately force update to the **previous bundle**.



## Force Update
When you set a bundle's `shouldForceUpdate` status to `true` in the console, users who have that bundle will immediately force update to the **latest bundle**.



## Git URL

You can set the git URL in the `hot-updater.config.ts` file.

```ts title="hot-updater.config.ts"
export default defineConfig({
  console: {
    gitUrl: "", // e.g. https://github.com/gronxb/hot-updater // [!code hl]
  },
});
```
When you set the git URL, the commit hash will be clickable and redirect you to the corresponding commit in your repository.

---

# Guides: "Deploy"
URL: https://hot-updater.dev/docs/guides/deploy
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/deploy.mdx

"This command is used to deploy the update to the specified platform."

## Checklist
1. Ensure `hot-updater.config.ts` is properly configured.
2. Wrap your components using `HotUpdater.wrap`.
3. Register the `babel-plugin`.
4. Include the native code.

If you haven't completed these steps, refer to the [Supabase Provider](/docs/managed-providers/supabase) guide.

## Options

```
Options:
  -p, --platform                     specify the platform (choices: "ios", "android")
  -t, --target-app-version   specify the target app version (semver format e.g. 1.0.0, 1.x.x)
  -f, --force-update                           force update the app (default: false)
  -o, --bundle-output-path   the path where the bundle.zip will be generated
  -i, --interactive                            interactive mode (default: false)
  -c, --channel                       specify the channel to deploy (default: "production")
  -m, --message                       Specify a custom message for this deployment. If not provided, the latest git commit message will be used as the deployment message
  -h, --help                                   display help for command
```

## Usage

### Interactive Mode

Interactive mode guides you through the deployment steps via keyboard inputs.

Execute the following command:

```package-install
npx hot-updater deploy -i
```

The `-i` (or `--interactive`) flag enables interactive keyboard input.
- This mode allows you to proceed through deployment steps interactively.

### For Continuous Deployment (CD) Pipelines

Use this mode for automating deployment in CI/CD pipelines.

Run the following command:

```package-install
npx hot-updater deploy -p 
```

- This mode is suitable for Continuous Deployment (CD) pipelines.

### Force Update

Deploy a forced update for emergency purposes. This will immediately apply the update.

Run the following command:

```package-install
npx hot-updater deploy -p  -f
```

The `-f` (or `--force-update`) flag enables force update.

### Channel

The `-c` (or `--channel`) flag specifies the release channel.

Run the following command:

```package-install
npx hot-updater deploy -p  -c ""
```

The `-c` (or `--channel`) flag specifies the release channel. The default value is `production`.

For more details about channels, refer to the [Channel Guide](/docs/guides/channel-management).

### Message

The `-m` (or `--message`) flag specifies the message.

Run the following command:

```package-install
npx hot-updater deploy -p  -m ""
```

## Force Update Flag Difference

| Update Type   | When Applied                                              | How to Enable                              |
|---------------|----------------------------------------------------------|-------------------------------------------|
| Default       | Downloads the update bundle in the background and applies it when the user restarts the app. | Default setting                           |
| Force Update  | Downloads the update bundle and applies it immediately.   | Use the `--force-update` flag or console. |

---

# Guides: "Simulate Test"
URL: https://hot-updater.dev/docs/guides/simulator-test
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/simulator-test.mdx

"Since hot-updater does not work in dev environment, you need to test it in Release mode as shown below."

## Checklist
- Make sure `hot-updater.config.ts` is properly configured.
- Make sure `HotUpdater.wrap` is properly implemented.


## Step 1: Simulator Release Mode

Run your app in Release mode to test hot-updater (it doesn't work in dev mode).


  
    **iOS:**
    ```sh
    cd ios && pod install && cd ..
    npx react-native run-ios --mode Release
    ```

    **Android:**
    ```sh
    npx react-native run-android --mode Release
    ```
  
  
    **iOS:**
    ```sh
    npx rock run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx rock run:android --variant Release
    ```
  
  
    **iOS:**
    ```sh
    npx expo run:ios --configuration Release
    ```

    **Android:**
    ```sh
    npx expo run:android --variant release
    ```
  


## Step 2: Deploy

Deploy with interactive mode and force update flag enabled in hot-updater deploy mode.

When [HotUpdater.wrap](/docs/react-native-api/wrap) is set up, updates will be applied when you restart the app.

You can check the update progress status using [useHotUpdaterStore](/docs/react-native-api/useHotUpdaterStore).





### For Normal Deployment

This is the standard deployment mode. After an update is created, users need to restart their app after downloading the bundle for the update to take effect.

```package-install
npx hot-updater deploy -i
```


### For Emergency Deployment

This is the emergency deployment mode. After an update is created, the bundle will automatically reload and apply the update as soon as users download it.

```package-install
npx hot-updater deploy -i --force-update
```


## Step 3: Rollback



When you set a bundle's `enabled` status to `false` in the console, users who have that bundle will immediately force update to the **previous bundle**.

Open the console and set the bundle's `enabled` status to `false`.

```package-install
npx hot-updater console
```

---

# Guides: "App Version Update Strategy"
URL: https://hot-updater.dev/docs/guides/update-strategies/app-version
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/update-strategies/app-version.mdx

"Manually target specific app versions for OTA updates instead of using automatic compatibility checks."

## Overview

The App Version strategy gives you manual control over which app versions receive updates. You specify exact versions or ranges when deploying, rather than relying on automatic fingerprint detection.

**When to use it**: Choose this if you prefer explicit version targeting over automated compatibility checks.

## Setup

Configure the strategy in your Hot Updater config:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "appVersion",
});
```

## Version Targeting

Use version ranges to control which app versions receive updates. The `-t` option accepts various expressions:

| Range | Who gets the update |
| :--- | :--- |
| `1.2.3` | Only version `1.2.3` |
| `*` | All versions |
| `1.2.x` | Any patch version of `1.2` |
| `1.2.3 - 1.2.7` | Versions `1.2.3` through `1.2.7` (inclusive) |
| `>=1.2.3 =1.2.0 =1.2.3 =1.2.3  -t "1.x.x"
```

Examples:
- `npx hot-updater deploy -p ios -t "1.0.0"` - Only version 1.0.0
- `npx hot-updater deploy -p android -t ">=1.2.0"` - Version 1.2.0 and above
- `npx hot-updater deploy -p ios -t "*"` - All versions

## Client Setup

Configure your React Native app:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server.com/api/update-check", {
    updateStrategy: "appVersion", // [!code ++]
  }),
})(App);
```

The client automatically constructs this endpoint:
```
GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId
```

## Testing the Endpoint

Test your update endpoint using curl:

```bash
curl "https://your-update-endpoint.com/check-update/app-version/ios/1.0.0/production/00000000-0000-0000-0000-000000000000/00000000-0000-0000-0000-000000000001"
```

Parameters:
- `:platform` - `ios` or `android`
- `:appVersion` - Current app version (e.g., `1.0.0`)
- `:channel` - Channel name (e.g., `production`, `staging`)
- `:minBundleId` - Minimum supported bundle ID
- `:bundleId` - Current bundle ID

---

# Guides: "Fingerprint Update Strategy"
URL: https://hot-updater.dev/docs/guides/update-strategies/fingerprint
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/guides/update-strategies/fingerprint.mdx

"Automatically prevent incompatible OTA updates by tracking native code changes with Expo's fingerprint library."

## Why Choose Fingerprint?

Fingerprint automatically detects native code changes and blocks incompatible OTA updates. This ensures only safe updates reach your users.

**Fingerprint vs App Version:**
- **Fingerprint** (Recommended): Automatic protection - detects native changes and blocks unsafe updates
- **App Version**: Manual control - you specify version targets, no automatic checking

Choose Fingerprint for automatic safety. Choose App Version for manual control.

## Setup

Fingerprint is the default strategy. Configure it explicitly if needed:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint", // Default strategy
});
```

### Include Additional Files (Optional)

Track extra files that affect native compatibility:

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint",
  fingerprint: {
    extraSources: [
      "config/native-config.json",
      "scripts/post-build.sh",
    ],
    debug: true,
  },
});
```

## Workflow

### Before App Store Submission

**Step 1: Generate Fingerprint**

Before building for App Store, generate the fingerprint:

```package-install
npx hot-updater fingerprint create
```

This creates a `fingerprint.json` file and embeds the hash in your native files:
- iOS: `ios/YourApp/Info.plist`
- Android: `android/app/src/main/res/values/strings.xml`

Example `fingerprint.json`:
```json
{
  "ios": {
    "hash": "11142b9062165fa48665f5efa095dd94e9e45eb0"
  },
  "android": {
    "hash": "c763ed5729a0bcccf23248ee0183ddf9016c2e6e"
  }
}
```

**Step 2: Build and Submit**

Build your app with the embedded fingerprint and submit to the App Store.

**Step 3: Deploy OTA Updates**

After your app is live, deploy JavaScript-only updates:

```package-install
npx hot-updater deploy
```

The system automatically ensures only compatible updates reach users.

### When Native Code Changes

Check if your fingerprint needs updating:

```package-install
npx hot-updater fingerprint
```

If there's a mismatch, create a new fingerprint:

```package-install
npx hot-updater fingerprint create
```

**Important**: After creating a new fingerprint, you must rebuild your app. The new fingerprint must be embedded in the app binary before deploying OTA updates.

## Client Setup

Configure your React Native app:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://your-update-server.com/api/update-check", {
    updateStrategy: "fingerprint", // [!code ++]
  }),
})(App);
```

The client automatically constructs this endpoint:
```
GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId
```

## How It Works

### JavaScript/UI Changes  OTA Update Safe

```javascript
//  Safe for OTA updates
// - Component logic changes
// - Style and layout updates
// - New screens
// - Business logic changes
// - API call modifications
```

**Result**: Fingerprint unchanged  OTA update deployed

### Native Code Changes  Rebuild Required

```bash
#  Requires native rebuild
# - New native modules (react-native-camera)
# - React Native version updates
# - Native iOS/Android code changes
# - Build configuration changes
```

**Result**: Fingerprint changed  OTA blocked  Rebuild needed

If you try to deploy with a changed fingerprint:

```bash
$ npx hot-updater deploy
 Fingerprint mismatch!
 Native code changed. You need to:
1. Run: npx hot-updater fingerprint create
2. Rebuild and resubmit your app
3. Then deploy OTA updates
```

## Advanced

### Multiple App Targets

`fingerprint create` automatically handles standard React Native projects. Only configure custom paths if you have:
- iOS app extensions (widgets, share extensions)
- Multiple Android build variants
- Non-standard project structure

```typescript title="hot-updater.config.ts"
export default defineConfig({
  updateStrategy: "fingerprint",
  platform: {
    ios: {
      infoPlistPaths: [
        "ios/YourApp/Info.plist",
        "ios/YourAppWidget/Info.plist",
        "ios/YourAppExtension/Info.plist"
      ]
    },
    android: {
      stringResourcePaths: [
        "android/app/src/main/res/values/strings.xml",
        "android/app/src/debug/res/values/strings.xml"
      ]
    }
  }
});
```

 Most projects don't need this - the defaults work perfectly.

### Testing the Endpoint

Test your update endpoint with curl:

```bash
curl "https://your-update-endpoint.com/check-update/fingerprint/ios/11142b9062165fa48665f5efa095dd94e9e45eb0/production/00000000-0000-0000-0000-000000000000/00000000-0000-0000-0000-000000000001"
```

Parameters:
- `:platform` - `ios` or `android`
- `:fingerprintHash` - Current fingerprint hash
- `:channel` - Channel name (e.g., `production`, `staging`)
- `:minBundleId` - Minimum supported bundle ID
- `:bundleId` - Current bundle ID

---

# Integration Plugins: "Datadog"
URL: https://hot-updater.dev/docs/integration-plugins/datadog
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/datadog.mdx

"The `withDatadog()` plugin for hot-updater enables automatic sourcemap upload to Datadog during the update bundle build process."

## Prerequisites

- Datadog Account: Sign up here if you don't have one.
- Auth Token: Generate a token from your Datadog dashboard. This must be defined as the environment variable `DATADOG_API_KEY`.
- Datadog host: in order to communicate with Datadog, you need to specify the host to which the Auth token refers using the environment variable `DATADOG_HOST` (e.g., `DATADOG_HOST=datadoghq.eu`)
- Install the plugin:

```package-install
npm install @hot-updater/datadog-plugin @datadog/datadog-ci --save-dev
```

## Step 1: Wrap Your Build Plugin

Use `withDatadog()` to wrap any compatible build plugin such as bare.

Once wrapped, sourcemaps will automatically be uploaded to Datadog when running the `hot-updater deploy` process.


  

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: withDatadog(
    bare({
      enableHermes: false, // or true, depending if you want to use it
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```



```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withDatadog(
    expo({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```




```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withDatadog(
    rock({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      buildNumber: "build number",       // [!code ++] The build number through which Datadog will sort the uploaded sourcemaps belonging to the same version
      releaseVersion: "release version",    // [!code ++] This is the release version that must match the release version used to stream logs from the app
      service: "service", // [!code ++] The datadog service to which the sourcemaps belong
    },
  ),
  // .. your other config
});
```






When `withDatadog()` wraps your build plugin, all generated sourcemaps are uploaded to Datadog automatically during the `hot-updater deploy` process.


## Step 3: Deploy

Now, every time you deploy, sourcemaps will be automatically uploaded to Datadog.

```package-install
npx hot-updater deploy -i
```

---

# Integration Plugins: "Re.Pack"
URL: https://hot-updater.dev/docs/integration-plugins/repack
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/repack.mdx

Integration plugin for Re.Pack bundler

## Introduction
Re.Pack is a modern bundler for React Native.

The `@hot-updater/repack` plugin is a plugin for the [Re.Pack](https://re-pack.dev/) bundler.

It is used to set the bundle ID (uuidv7) and channel at build time.

If you don't do this, you'll get an error saying there's no bundle ID when running the `hot-updater deploy` command.

## Installation

```package-install
npm install @hot-updater/repack --save-dev
```

## Usage

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```

---

# Integration Plugins: "Sentry"
URL: https://hot-updater.dev/docs/integration-plugins/sentry
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/integration-plugins/sentry.mdx

"The `withSentry()` plugin for hot-updater enables automatic sourcemap upload to Sentry during the update bundle build process."

## Prerequisites

- Sentry Account: Sign up here if you don't have one.
- Auth Token: Generate a token with the project:releases and org:read scopes from your Sentry dashboard.
- Install the plugin:

```package-install
npm install @hot-updater/sentry-plugin --save-dev
```

## Step 1: Configure Sentry


  
    

    You need to configure Metro. Please refer to the [Sentry documentation](https://docs.sentry.io/platforms/react-native/manual-setup/metro/) above for detailed setup instructions.

    ```js title="metro.config.js"
    const { getDefaultConfig } = require("@react-native/metro-config");
    const { withSentryConfig } = require("@sentry/react-native/metro");

    const config = getDefaultConfig(__dirname);
    module.exports = withSentryConfig(config);
    ```
  
  

  You need to configure Re.Pack.

```package-install
repack-plugin-sentry
```

```js title="rspack.config.mjs"
export default {
  // ... your other config
  plugins: [
    // ... your other plugins
    new SentryDebugIdPlugin(), // [!code ++]
  ],
};
```
  




## Step 2: Wrap Your Build Plugin

Use `withSentry()` to wrap any compatible build plugin such as bare.

Once wrapped, sourcemaps will automatically be uploaded to Sentry when running the `hot-updater deploy` process.


  

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: withSentry(
    bare({
      enableHermes: false,
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```



```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withSentry(
    expo({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```




```ts title="hot-updater.config.ts"
export default defineConfig({
  build: withSentry(
    rock({
      sourcemap: true, // [!code ++] Required for sourcemap upload
    }),
    {
      org: "your-org-slug",       // [!code ++] Your Sentry organization slug
      project: "your-project",    // [!code ++] Your Sentry project slug
      authToken: process.env.SENTRY_AUTH_TOKEN!, // [!code ++]
    },
  ),
  // .. your other config
});
```






When `withSentry()` wraps your build plugin, all generated sourcemaps are uploaded to Sentry automatically during the `hot-updater deploy` process.


## Step 3: Deploy

Now, every time you deploy, sourcemaps will be automatically uploaded to Sentry.

```package-install
npx hot-updater deploy -i
```

---

# Managed-Hosted: "AWS S3 Storage + Lambda@Edge Function"
URL: https://hot-updater.dev/docs/managed-providers/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/aws.mdx

"This guide walks you through setting up `hot-updater` with AWS S3 Storage and Lambda@Edge Function in a React Native project. You'll configure the environment, install required packages, and initialize AWS for seamless updates."

## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **AWS Account**: Sign up at [AWS](https://aws.amazon.com) if you don't have one.
- **AWS CLI**: Install the AWS CLI and configure your credentials.

## Required AWS Permissions

Hot Updater requires specific AWS IAM permissions for setup and ongoing usage:

### 1. Initialization (One-Time Setup)

Used for `hot-updater init`:
* `AmazonS3FullAccess`: Create and read S3 buckets.
* `AWSLambda_FullAccess`: Create and update Lambda functions.
* `CloudFrontFullAccess`: Manage CloudFront distributions.
* `IAMFullAccess`: Create IAM roles for Lambda@Edge.
* `SSMFullAccess`: Create Access to SSM Parameters for storing CloudFront key pairs.

### 2. Ongoing Usage

Used for `hot-updater deploy` and `hot-updater console`:
* `AmazonS3FullAccess`: Manage bundles and metadata in the S3 bucket.

For ongoing usage, create a separate access token with limited permissions.

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure AWS

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select AWS + Lambda@Edge as the provider for handling updates.
During the setup, you will be prompted to:
1. **Choose AWS Login Method**: Select between AWS Access Key or SSO login
2. **Enter AWS Credentials**: Input your AWS credentials with required permissions
3. **Select Region**: Choose an AWS region for your S3 bucket
4. **Select S3 Bucket**: Choose an existing bucket or create a new one
5. **Create IAM Role**: Create or select an IAM role for Lambda@Edge
6. **Deploy Lambda Function**: Deploy the Lambda@Edge function to handle updates
7. **Create/Update CloudFront Distribution**: Create or update a CloudFront distribution

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
# This key was generated via SSO login and may expire. Update it with an S3FullAccess and CloudFrontFullAccess key.
HOT_UPDATER_S3_ACCESS_KEY_ID=your-access-key-id
# This key was generated via SSO login and may expire. Update it with an S3FullAccess and CloudFrontFullAccess key.
HOT_UPDATER_S3_SECRET_ACCESS_KEY=your-secret-access-key

HOT_UPDATER_S3_BUCKET_NAME=your-s3-bucket-name
HOT_UPDATER_S3_REGION=your-region
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating AWS with your project.

```ts title="hot-updater.config.ts"

config({ path: ".env.hotupdater" });

const commonOptions = {
  bucketName: process.env.HOT_UPDATER_S3_BUCKET_NAME!,
  region: process.env.HOT_UPDATER_S3_REGION!,
  credentials: {
    accessKeyId: process.env.HOT_UPDATER_S3_ACCESS_KEY_ID!,
    secretAccessKey: process.env.HOT_UPDATER_S3_SECRET_ACCESS_KEY!,
  },
};

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: s3Storage(commonOptions),
  database: s3Database({
    ...commonOptions,
    cloudfrontDistributionId: process.env.HOT_UPDATER_CLOUDFRONT_DISTRIBUTION_ID!,
  }),
});
```

## Step 4: Change `.env` file (Optional)

By this point, the .env file should already be created. The token inside was generated when you ran the `hot-updater init` command.

The token may have excessive permissions due to infrastructure setup or expire if SSO was used.

To avoid issues, update it with a permanent token with `S3FullAccess` and `CloudFrontFullAccess`.

```ts title=".env"
HOT_UPDATER_S3_ACCESS_KEY_ID=your-access-key-id
HOT_UPDATER_S3_SECRET_ACCESS_KEY=your-secret-access-key
```


## Step 5: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https:///api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```


## Step 6: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.





## Step 7: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS


```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your AWS dashboard for the newly created bucket, Lambda@Edge function, and CloudFront distribution.
2. Test the HotUpdater integration in your React Native app.


You're all set!  Start using hot-updater with AWS for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Cloudflare Provider"
URL: https://hot-updater.dev/docs/managed-providers/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/cloudflare.mdx

"This guide walks you through setting up `hot-updater` with Cloudflare in a React Native project. You'll configure the environment, install required packages, and initialize Cloudflare for seamless updates."

## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **Cloudflare Account**: Sign up at [Cloudflare](https://cloudflare.com) if you don't have one.
- **Cloudflare API Token**: Create an API Token at https://dash.cloudflare.com/{your-account-id}/api-tokens with **R2 Edit** & **D1 Edit** permissions

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Cloudflare

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Cloudflare as the provider for handling updates.

During the setup, you will be prompted to:
1. **Login to Cloudflare**: Sign in to your Cloudflare account with wrangler
2. **Enter R2 & D1 API Token**: Input your API token with R2 and D1 permissions
3. **Select R2 Bucket**: Choose an existing R2 bucket or create a new one
4. **Select D1 Database**: Choose an existing D1 database or create a new one
5. **Run D1 Migration**: Execute database migrations for D1
6. **Deploy Worker**: Deploy the Cloudflare Worker for update management

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID=your-account-id
HOT_UPDATER_CLOUDFLARE_R2_BUCKET_NAME=your-r2-bucket-name
HOT_UPDATER_CLOUDFLARE_D1_DATABASE_ID=your-d1-database-id
HOT_UPDATER_CLOUDFLARE_API_TOKEN=your-api-token
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Cloudflare with your project.

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: r2Storage({
    bucketName: process.env.HOT_UPDATER_CLOUDFLARE_R2_BUCKET_NAME!,
    accountId: process.env.HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.HOT_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
  database: d1Database({
    databaseId: process.env.HOT_UPDATER_CLOUDFLARE_D1_DATABASE_ID!,
    accountId: process.env.HOT_UPDATER_CLOUDFLARE_ACCOUNT_ID!,
    cloudflareApiToken: process.env.HOT_UPDATER_CLOUDFLARE_API_TOKEN!,
  }),
});

```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://..workers.dev/api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.






## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Cloudflare dashboard for the newly created bucket, D1 database, and worker.
2. Test the HotUpdater integration in your React Native app.


You're all set!  Start using hot-updater with Cloudflare for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Firebase Provider"
URL: https://hot-updater.dev/docs/managed-providers/firebase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/firebase.mdx

"This guide walks you through setting up `hot-updater` with Firebase in a React Native project. You'll configure the environment, install required packages, and initialize Firebase for seamless updates."

## Prerequisites

Before you begin, make sure the following are ready:
- **Node.js**: Version 20 or later is recommended.
- **Firebase Project**: Create a new project at [Firebase](https://firebase.google.com) if you dont have one.
- **Firebase Storage**: Create a new storage bucket at [Firebase](https://firebase.google.com) if you dont have one.
- **Firestore**: Create a new firestore database at [Firebase](https://firebase.google.com) if you dont have one.

## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Firebase

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Firebase as the provider for handling updates.

During the setup, you will be prompted to:
1. **Create or Select a Firebase Project**: Choose an existing project or create a new one.
2. **Configure Storage**: Select an existing storage bucket or create a new public bucket to store updates.
3. **Deploy Firestore Indexes**: create a new one to store updates.
4. **Deploy Functions**: Deploy a Firebase Function v2 called `hot-updater`.
5. **Add IAM Policy**: Add a new IAM policy to the service account of the function.

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_FIREBASE_PROJECT_ID=your-project-id
HOT_UPDATER_FIREBASE_STORAGE_BUCKET=your-bucket-name
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=your-credentials.json
```




If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Firebase with your project.
- `.env`: **IMPORTANT**:
Make sure to set the `GOOGLE_APPLICATION_CREDENTIALS` environment variable to the path of your downloaded Firebase credentials JSON file.
This is critical for Firebase authentication to work properly.
For more details, see: https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments

```js title=".env"
HOT_UPDATER_FIREBASE_PROJECT_ID=your-project-id
HOT_UPDATER_FIREBASE_STORAGE_BUCKET=your-bucket-name
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=your-credentials.json
```

```ts title="hot-updater.config.ts"
import 'dotenv/config';

// https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments
// Check your .env file and add the credentials
// Set the GOOGLE_APPLICATION_CREDENTIALS environment variable to your credentials file path
// Example: GOOGLE_APPLICATION_CREDENTIALS=./firebase-adminsdk-credentials.json
const credential = admin.credential.applicationDefault();

export default defineConfig({
  build: bare({
    enableHermes: true,
  }),
  storage: firebaseStorage({
    projectId: process.env.HOT_UPDATER_FIREBASE_PROJECT_ID!,
    storageBucket: process.env.HOT_UPDATER_FIREBASE_STORAGE_BUCKET!,
    credential,
  }),
  database: firebaseDatabase({
    projectId: process.env.HOT_UPDATER_FIREBASE_PROJECT_ID!,
    credential,
  }),
});
```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https:///api/check-update", { // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }), // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
npm install @hot-updater/repack --save-dev
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.





## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Firebase dashboard for the newly created firebase function.
2. Test the HotUpdater integration in your React Native app.


Youre all set!  Start using hot-updater with Firebase for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Managed-Hosted: "Supabase Provider"
URL: https://hot-updater.dev/docs/managed-providers/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/managed-providers/supabase.mdx

"This guide walks you through setting up `hot-updater` with Supabase in a React Native project. You'll configure the environment, install required packages, and initialize Supabase for seamless updates."

## Prerequisites

Before you begin, make sure the following are ready:
- **Docker Or OrbStack**: Install it via [Docker](https://docs.docker.com/get-docker/) or [OrbStack](https://orbstack.dev/).
- **Node.js**: Version 20 or later is recommended.
- **Supabase CLI**: Install it via `npx supabase`.
- **Supabase Account**: Sign up at [Supabase](https://supabase.com) if you don't have one.


## Step 1: Install Required Packages

Run the following command to install dependencies:

```package-install
npm install hot-updater --save-dev
```

## Step 2: Configure Supabase

Run the initialization script to start the interactive setup process. Use the following command with your preferred package manager:

```package-install
npx -y supabase login
npx hot-updater init
```


  

1. **Select a Build Plugin**: Choose a build plugin for your project (e.g., Bare (React Native CLI) for React Native).
2. **Select a Provider**: Select Supabase as the provider for handling updates.

During the setup, you will be prompted to:
1. **Create or Select a Supabase Organization**: Choose an existing organization or create a new one.
2. **Create or Select a Project**: Choose an existing project or create a new one within your organization.
3. **Configure Storage**: Select an existing storage bucket or create a new public bucket to store updates.
4. **Database Migration**: create a new one to store updates.
5. **Deploy Edge Function**: Deploy a Supabase Edge Function called `update-server`.

  


Once the setup is complete, a `.env` file will be generated containing the following keys:

```
HOT_UPDATER_SUPABASE_ANON_KEY=your-anon-key
HOT_UPDATER_SUPABASE_BUCKET_NAME=your-bucket-name
HOT_UPDATER_SUPABASE_URL=https://your-project-id.supabase.co
```





If you're **not** using the `react-native-dotenv` solution, the tokens from your `.env` file will not be included in your app bundle and are therefore not exposed to risks. However, if you're still concerned,

please refer to the article below for more details:
[Security](/docs/policy/security#plugin-token-protection)



## Step 3: Generated Configurations
During the initialization process, the following file is automatically generated:

- `hot-updater.config.ts`: This file contains the configuration settings for integrating Supabase with your project.

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});
```

## Step 4: Add HotUpdater to Your Project

The HotUpdater component wraps your application, enabling seamless delivery of updates and fallback UI during updates. Follow these steps to integrate it into your App.tsx:

```tsx title="App.tsx"
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("https://.supabase.co/functions/v1/update-server", {  // [!code ++]
    updateStrategy: "appVersion", // or "fingerprint" // [!code ++]
  }),  // [!code ++]
  requestHeaders: {
    // if you want to use the request headers, you can add them here
  },
  fallbackComponent: ({ progress, status }) => (
    
      {/* You can put a splash image here. */}

      
        {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
      
      {progress > 0 ? (
        
          {Math.round(progress * 100)}%
        
      ) : null}
    
  ),
})(App);

```

## Step 5: Add Babel / Re.Pack / Expo Plugin to Your Project

In this step, you will configure Babel to set the bundle ID at build time. This is necessary for integrating the `hot-updater` plugin into your project.


  

Add the following to your `babel.config.js` file:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};

```


Add the following to your `rspack.config.mjs` file:
```package-install
-updater/repack
```

```js title="rspack.config.mjs"
export default {
  // ...
  plugins: [
    new Repack.RepackPlugin(),
    new HotUpdaterPlugin() // [!code ++]
  ],
};
```




Add the plugin to your `app.json` file as shown below:

```json title="app.json"
{
  "expo": {
    "plugins": [
      [
        "@hot-updater/react-native",
        {
          "channel": "production"
        }
      ]
    ]
  }
}
```

```package-install
npx expo prebuild
```

Run the following command to customize your Babel configuration:

```package-install
npx expo customize babel.config.js
```

Add the following to your `babel.config.js` file:

```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin', // [!code ++]
  ],
};
```


This process automatically generates the code that needs to be added in Step 6.






## Step 6: Add Native Code

To complete the integration of `hot-updater`, you'll need to add native code modifications for both Android and iOS platforms. This step ensures the `hot-updater` can interact with your app's underlying framework to apply updates seamlessly.

### Android


  
    ```kt title="android/app/src/main/java/com//MainApplication.kt"
    package com.hotupdaterexample

    import android.app.Application
    import com.facebook.react.PackageList
    import com.facebook.react.ReactApplication
    import com.facebook.react.ReactHost
    import com.facebook.react.ReactNativeApplicationEntryPoint.loadReactNative
    import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
    import com.hotupdater.HotUpdater

    class MainApplication : Application(), ReactApplication {

    override val reactHost: ReactHost by lazy {
      getDefaultReactHost(
        context = applicationContext,
        packageList =
          PackageList(this).packages.apply {
            // Packages that cannot be autolinked yet can be added manually here, for example:
            // add(MyReactNativePackage())
          },
        jsBundleFilePath = HotUpdater.getJSBundleFile(applicationContext), // [!code ++]
      )

    }

    override fun onCreate() {
      super.onCreate()
      loadReactNative(this)
    }
    }
    ```

  
  
```kt title="android/app/src/main/java/com//MainApplication.kt"
package com.hotupdaterexample

import android.app.Application
import com.facebook.react.PackageList
import com.facebook.react.ReactApplication
import com.facebook.react.ReactHost
import com.facebook.react.ReactNativeHost
import com.facebook.react.ReactPackage
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint.load
import com.facebook.react.defaults.DefaultReactHost.getDefaultReactHost
import com.facebook.react.defaults.DefaultReactNativeHost
import com.facebook.react.soloader.OpenSourceMergedSoMapping
import com.facebook.soloader.SoLoader
import com.hotupdater.HotUpdater // [!code ++]

class MainApplication : Application(), ReactApplication {

  override val reactNativeHost: ReactNativeHost =
      object : DefaultReactNativeHost(this) {
        override fun getPackages(): List =
            PackageList(this).packages.apply {
              // Packages that cannot be autolinked yet can be added manually here, for example:
              // add(MyReactNativePackage())
            }

        override fun getJSMainModuleName(): String = "index"

        override fun getUseDeveloperSupport(): Boolean = BuildConfig.DEBUG

        override val isNewArchEnabled: Boolean = BuildConfig.IS_NEW_ARCHITECTURE_ENABLED
        override val isHermesEnabled: Boolean = BuildConfig.IS_HERMES_ENABLED

        override fun getJSBundleFile(): String? {  // [!code ++]
          return HotUpdater.getJSBundleFile(applicationContext)  // [!code ++]
        }  // [!code ++]
      }

  override val reactHost: ReactHost
    get() = getDefaultReactHost(applicationContext, reactNativeHost)

  override fun onCreate() {
    super.onCreate()
    SoLoader.init(this, OpenSourceMergedSoMapping)
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      load()
    }
  }
}
```
  
  
  ```java title="android/app/src/main/java/com//MainApplication.java"

package com.hotupdaterexample;

import android.app.Application;
import com.facebook.react.PackageList;
import com.facebook.react.ReactApplication;
import com.facebook.react.ReactNativeHost;
import com.facebook.react.ReactPackage;
import com.facebook.react.defaults.DefaultNewArchitectureEntryPoint;
import com.facebook.react.defaults.DefaultReactNativeHost;
import com.facebook.soloader.SoLoader;
import java.util.List;
import com.hotupdater.HotUpdater;  // [!code ++]

public class MainApplication extends Application implements ReactApplication {

  private final ReactNativeHost mReactNativeHost =
      new DefaultReactNativeHost(this) {
        @Override
        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }

        @Override
        protected List getPackages() {
          @SuppressWarnings("UnnecessaryLocalVariable")
          List packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          return packages;
        }

        @Override
        protected String getJSMainModuleName() {
          return "index";
        }

        @Override // [!code ++]
        protected String getJSBundleFile() {  // [!code ++]
            return HotUpdater.Companion.getJSBundleFile(this.getApplication().getApplicationContext());  // [!code ++]
        }  // [!code ++]

        @Override
        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }

        @Override
        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }
      };

  @Override
  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }

  @Override
  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);

    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }
}

```

  


### iOS



```swift title="ios//AppDelegate.swift"
import UIKit
import React
import React_RCTAppDelegate
import ReactAppDependencyProvider
import HotUpdater // [!code ++]

@main
class AppDelegate: RCTAppDelegate {
  override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -> Bool {
    self.moduleName = "HotUpdaterExample"
    self.dependencyProvider = RCTAppDependencyProvider()

    // You can add your custom initial props in the dictionary below.
    // They will be passed down to the ViewController used by React Native.
    self.initialProps = [:]

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  override func sourceURL(for bridge: RCTBridge) -> URL? {
    self.bundleURL()
  }

  override func bundleURL() -> URL? {
#if DEBUG
    RCTBundleURLProvider.sharedSettings().jsBundleURL(forBundleRoot: "index")
#else
    Bundle.main.url(forResource: "main", withExtension: "jsbundle") // [!code --]
    HotUpdater.bundleURL() // [!code ++]
#endif
  }
}

```


```objc title="ios//AppDelegate.mm"
#import "AppDelegate.h"
#import  // [!code ++]
#import 

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.moduleName = @"HotUpdaterExample";
  // You can add your custom initial props in the dictionary below.
  // They will be passed down to the ViewController used by React Native.
  self.initialProps = @{};

  return [super application:application didFinishLaunchingWithOptions:launchOptions];
}

- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge
{
  return [self bundleURL];
}

- (NSURL *)bundleURL
{
#if DEBUG
  return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@"index"];
#else
  return [[NSBundle mainBundle] URLForResource:@"main" withExtension:@"jsbundle"]; // [!code --]
  return [HotUpdater bundleURL]; // [!code ++]
#endif
}

@end
```




## Verifying the Setup
1. Check your Supabase dashboard for the newly created bucket and edge function.
2. Test the HotUpdater integration in your React Native app.


You're all set!  Start using hot-updater with Supabase for seamless updates in your React Native app.

This document simplifies the initialization process, making it easy for developers to get started with minimal friction.

---

# Policy: "When to Submit Your App for Review"
URL: https://hot-updater.dev/docs/policy/app-review
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/policy/app-review.mdx

"`HotUpdater` enables seamless updates to JavaScript (JS) files and assets required by your app, bypassing the app store review process in many cases. However, certain changes, particularly those involving native code (e.g., written in Swift/Objective-C for iOS or Kotlin/Java for Android), require app store review. Below, we outline when you need to submit your app for review and when `HotUpdater` can handle updates independently."

## Scenarios Requiring App Store Review (Native Code Changes)


1. **Initial Integration of `HotUpdater`**  
   During the first integration of `HotUpdater`, native code modifications are required. This necessitates submitting your app for app store review.

2. **Native Code Changes**  
   Any updates to native code, such as Swift, Objective-C, Kotlin, or Java, require an app store review before the changes can be distributed.

3. **Installing Native-Dependent Libraries**  
   When using third-party libraries in React Native that modify native code, your app must go through app store review. A key indicator of native changes is the need for commands like:
   ```bash
   cd ios && pod install && cd ..
   ```


## Scenarios Compatible with HotUpdater (No App Store Review)

Certain updates can be performed entirely via HotUpdater, allowing you to bypass the app store review process:

### JavaScript Code Updates

Updates that only modify JS code can be handled by HotUpdater without review.

```tsx
   export default function App() {
       return (
           
             Hello // [!code --]
             Update Hello // [!code ++]
           
       );
   }
   ```

### Asset Updates via `require`

Changes to assets referenced using `require` (e.g., images or media files) can also be distributed via HotUpdater.

```tsx
    // [!code --]
    // [!code ++]
   ```


### JavaScript Library Updates

Updates that involve only JS library changes are compatible with HotUpdater:

```sh
> npm install lodash zustand ...
```

## Understanding HotUpdater Package Versioning

The HotUpdater versioning system helps determine whether app store review is necessary:
| **Version Type** | **Example**       | **Changes**                                                                 | **Review Required?**        |
|-------------------|-------------------|-----------------------------------------------------------------------------|-----------------------------|
| Patch Version     | `0.5.10  0.5.11` | Only JS logic is updated.                                                  | No                          |
| Minor Version     | `0.5.10  0.6.0` | Updates include JS changes and minor optimizations in the native code.     | Yes                         |
| Major Version     | `0.5.10  1.0.0` | Significant changes to native code, often involving feature enhancements.  | Yes                         |

If the version change only affects the `0.5.x` part of the package (patch version), you can update the `hot-updater` package without requiring an app store review, as the updates are limited to JS logic. However, if the `0.x.0` portion changes (major or minor version), it indicates changes in the native code. In these cases, the app must go through the app store review process.

### Key Notes on Versioning
-	Patch Versions (x.x.Patch): Updates limited to JS logic (e.g., bug fixes or performance improvements). No app store review required.
-	Minor Versions (x.Minor.x): May include minor changes to native code, requiring app store review.
-	Major Versions (Major.x.x): Introduce significant updates to native code, always requiring app store review.

### Summary

To ensure a smooth update process:
-	Use HotUpdater for JS updates and asset changes to avoid app store reviews.
-	Submit your app for review when native code changes or third-party libraries affecting native code are integrated.
-	Follow HotUpdater versioning guidelines to determine when a review is required.

---

# Policy: "Security"
URL: https://hot-updater.dev/docs/policy/security
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/policy/security.mdx

"Best practices for protecting plugin tokens and sensitive data"

## Plugin Token Protection

Developers may worry that sensitive tokens defined in the `hot-updater.config.ts` file might be bundled into the app and exposed in production.

Using environment variables is simply for populating the token value in the `hot-updater.config.ts` file. This is, in fact, unrelated to React Native.

```ts title="hot-updater.config.ts"
config({ path: ".env.hotupdater" });

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
    bucketName: process.env.HOT_UPDATER_SUPABASE_BUCKET_NAME!,
  }),
  database: supabaseDatabase({
    supabaseUrl: process.env.HOT_UPDATER_SUPABASE_URL!,
    supabaseAnonKey: process.env.HOT_UPDATER_SUPABASE_ANON_KEY!,
  }),
});

```

## Clarification

The `hot-updater.config.ts` file is not included in the apps build. Instead, it serves as a configuration layer specifically for communicating with the `hot-updater` CLI. As a result, sensitive tokens defined in this file are not part of the distributed application code.

What is actually included in the apps build is as follows:
```ts
export default HotUpdater.wrap({
  source: "https://",
});
```

Here, the source URL is included in the app code, but sensitive environment variables, such as `HOT_UPDATER_SUPABASE_ANON_KEY` tokens, are not bundled.

## Potential Token Exposure


If you're **not** using react-native-dotenv, tokens won't be included in your app by default. This is a guideline for projects using react-native-dotenv.

Using tools like react-native-dotenv can expose sensitive tokens in your app build. To avoid this, only include non-sensitive or publicly safe variables in your configuration.


If youre using tools like `react-native-dotenv` to read environment variables and inject them into the app during runtime, sensitive tokens might be exposed. To avoid this, ensure that only non-sensitive or publicly safe data is included in your app build.

### Example: If you are using `react-native-dotenv` Babel Configuration

To ensure safe handling of environment variables, you can whitelist only the necessary variables using `react-native-dotenv` in your Babel configuration:
```js title="babel.config.js"
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    'hot-updater/babel-plugin',
    [
      'module:react-native-dotenv',
      {
        envName: 'APP_ENV',
        allowlist: ['HOT_UPDATER_SUPABASE_ANON_KEY', 'HOT_UPDATER_CLOUDFLARE_API_TOKEN'],  Do not add private keys to allowlist // [!code --]
        allowlist: ['HOT_UPDATER_SUPABASE_URL'], //  Only add public keys that are safe to expose to allowlist // [!code ++]
        path: '.env.hotupdater', //  Use .env.hotupdater file separate from .env file
      },
    ],
  ],
};
```

## Best Practices

1. Restrict Exposure: Only include environment variables that are safe for public access in your app build.
2. Use Whitelists: Use tools like react-native-dotenv to define a whitelist of allowed environment variables.
3. Keep Sensitive Data Out of Builds: Store sensitive data securely on your server or backend, and ensure it is only accessed during server-side operations.
4. Use `react-native-keys` to manage keys.

---

# React Native API: "addEventListener"
URL: https://hot-updater.dev/docs/react-native-api/addListener
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/addListener.mdx

"The `addEventListener` function allows you to listen for specific events emitted by the HotUpdater. This is useful for tracking update progress or other events during the update process."

For most use cases involving bundle download progress bar displays, it's more convenient to use the store hook instead of this listener. See [useHotUpdaterStore](./useHotUpdaterStore).


## Usage

Use `addEventListener` to subscribe to HotUpdater events. It returns an unsubscribe function to clean up the listener when it's no longer needed.

```tsx
const unsubscribe = HotUpdater.addListener("onProgress", ({ progress }) => {
  console.log(`Update progress: ${progress * 100}%`);
});

// Later, when you no longer need the listener
unsubscribe();
```

## Event Type

The `HotUpdaterEvent` type defines the available events and their corresponding payloads.

```typescript
export type HotUpdaterEvent = {
  onProgress: {
    progress: number;
  };
};
```

## Parameters

| Parameter   | Type                                  | Required | Description                                 |
|-------------|---------------------------------------|----------|---------------------------------------------|
| `eventName` | `keyof HotUpdaterEvent`                |         | The name of the event to listen for.          |
| `listener`  | `(event: HotUpdaterEvent[T]) => void` |         | The callback function to handle the event.    |

## Return Value

The `addEventListener` function returns a cleanup function that removes the event listener when called.

```typescript
const unsubscribe = HotUpdater.addListener("onProgress", ({ progress }) => {
  console.log(`Update progress: ${progress * 100}%`);
});

// Unsubscribe when done
unsubscribe();
```

## Example

Here's an example of how to use `addEventListener` in a React Native component:

```tsx
function App() {
  useEffect(() => {
    const unsubscribe = addListener("onProgress", ({ progress }) => {
      console.log(`Update progress: ${progress * 100}%`);
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return (
    
      Hello World
    
  );
}

export default App;
```

---

# React Native API: "checkForUpdate"
URL: https://hot-updater.dev/docs/react-native-api/checkForUpdate
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/checkForUpdate.mdx

"The `checkForUpdate` function checks if there is an available update for the app by comparing the current app version and platform with the update server's bundle information."

## Usage

Use `checkForUpdate` to verify if an update bundle is available. You need to provide the source of the update server and optionally, request headers.

```tsx
async function checkForAppUpdate() {
  try {
    const updateInfo = await HotUpdater.checkForUpdate({
      source: getUpdateSource("", {
        updateStrategy: "appVersion", // or "fingerprint"
      }),
      requestHeaders: {
        Authorization: "Bearer ",
      },
    });

    if (!updateInfo) {
      return {
        status: "UP_TO_DATE",
      };
    }

    /**
     * You can apply updates using one of two methods:
     * 
     * Method 1: Use the updateBundle() method from the updateInfo object
     * - A convenience method built into the return value from checkForUpdate
     * - Performs the same function as HotUpdater.updateBundle with all required arguments pre-filled
     */
    await updateInfo.updateBundle();

    /**
     * Method 2: Call HotUpdater.updateBundle() directly
     * - Explicitly pass the necessary values extracted from updateInfo
     */
    // await HotUpdater.updateBundle({
    //   bundleId: updateInfo.id,
    //   fileUrl: updateInfo.fileUrl,
    //   status: updateInfo.status,
    // });

    if (updateInfo.shouldForceUpdate) {
      await HotUpdater.reload();
    }
    return updateInfo;
  } catch (error) {
    console.error("Failed to check for update:", error);
    return null;
  }
}

```

## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.

## Parameters

The `checkForUpdate` function accepts the following parameters:

| Parameter       | Type                | Required | Description                                      |
|-----------------|---------------------|----------|--------------------------------------------------|
| `source`        | `string`            |         | The URL of the update server.                     |
| `requestHeaders`| `Record` |         | Optional headers to include in the update request. |

## Return Value

The function returns an object of type `UpdateInfo` or `null` if the app is up to date.

```ts
export type UpdateStatus = "ROLLBACK" | "UPDATE";

export interface UpdateInfo {
  id: string;
  shouldForceUpdate: boolean;
  fileUrl: string | null;
  message: string | null;
  status: UpdateStatus;
}
```

### Example Return Value

```json
{
  "id": "01952bbd-e7b2-7931-aee8-2e2187caa0ce",
  "shouldForceUpdate": true,
  "status": "UPDATE",
  "fileUrl": "https://example.com/bundles/update.bundle",
  "message": "This is a test message",
}
```

---

# React Native API: "getChannel"
URL: https://hot-updater.dev/docs/react-native-api/getChannel
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/getChannel.mdx

"The `HotUpdater.getChannel()` function retrieves the current release channel of the app. This is useful when you want to determine which channel updates are being applied from."

By default, if no channel is specified, the app is assigned to the `production` channel.

For more details about channels, refer to the [Channel Guide](/docs/guides/channel-management).

## Usage

You can use `HotUpdater.getChannel()` to dynamically check the release channel in your application logic.

### Example

```tsx
function App() {
  const channel = HotUpdater.getChannel();

  return (
    
      Current Channel: {channel}
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```

## Behavior

- If `releaseChannel` is set in `hot-updater.config.ts`, `HotUpdater.getChannel()` returns that value.
- If no channel is set, the default is `production`.
- Channels help separate environments such as `dev`, `staging`, and `production`, ensuring that updates are applied correctly.
- The initial channel is injected into the native app during the build process based on the `releaseChannel` specified in `hot-updater.config.ts`.
- After the app is built, updates can be deployed to the correct channel using `hot-updater deploy -c `, such as `hot-updater deploy -c production` or `hot-updater deploy -c dev`.
- **Important**: Channel changes require rebuilding the native app to take effect. Simply changing the channel in the configuration file or through deployment commands will not update the channel of an already built app.
- **It is crucial to set the correct channel during the initial build**, as the app will continue to receive updates only from that specified channel.

## Configuration Example (`hot-updater.config.ts`)

```tsx
config({ path: ".env.hotupdater" });

export default defineConfig({
  releaseChannel: "dev", // Specifying the release channel
  build: ...,
  storage: ...,
  database: ...,
});
```

With this configuration, `HotUpdater.getChannel()` will return `"dev"`. This ensures that all future updates are correctly applied to the `dev` channel.

---

# React Native API: "isUpdateDownloaded"
URL: https://hot-updater.dev/docs/react-native-api/isUpdateDownloaded
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/isUpdateDownloaded.mdx

"Returns whether an update bundle has finished downloading in the current app session and is ready to be applied on reload."

## Usage

- Returns `true` when the download `progress` has reached `1.0`.
- Returns `false` while downloading or before any download starts.
- Resets to `false` automatically when a new download starts.

```tsx
async function maybeApplyUpdate() {
  if (HotUpdater.isUpdateDownloaded()) {
    await HotUpdater.reload();
  }
}
```

### Skip `checkForUpdate` when a download already exists

If a bundle has already finished downloading in this session, you can skip `checkForUpdate()` and just prompt the user to reload.

```tsx
async function checkAndUpdate() {
  // Avoid network call if an update is already downloaded and awaiting reload
  if (HotUpdater.isUpdateDownloaded()) {
    // e.g., show a "Restart to update" CTA or reload immediately
    return;
  }

  const updateInfo = await HotUpdater.checkForUpdate({
    source: getUpdateSource("", {
      updateStrategy: "appVersion", // or "fingerprint"
    }),
    // requestHeaders: { Authorization: "Bearer " },
  });

  if (!updateInfo) return;

  const ok = await updateInfo.updateBundle();
  if (!ok) return;

  if (updateInfo.shouldForceUpdate) {
    await HotUpdater.reload();
  }
}
```

## Details

- This value is derived from the internal `progress` state managed by `useHotUpdaterStore()`.
- It is session-scoped: it does not persist across app restarts.
- Use this when you need to decide whether to show a "Restart to update" UI or trigger a controlled reload.

```tsx
export function UpdateButton() {
  const { progress, isUpdateDownloaded } = useHotUpdaterStore();
  return (
     HotUpdater.reload()}
      disabled={!isUpdateDownloaded}
    />
  );
}
```

---

# React Native API: "reload"
URL: https://hot-updater.dev/docs/react-native-api/reload
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/reload.mdx

"By default, the `shouldForceUpdate` flag is `false`, the bundle is downloaded but not applied until the user restarts the app."

## Usage

Calling `HotUpdater.reload()` reloads the app. If there is a completed update bundle ready to be applied, it will be applied immediately.



The `shouldForceUpdate` flag simply downloads the bundle and calls reload immediately.


You can use it as shown below, but it is recommended to use it together with the `useHotUpdaterStore().progress value.

Refer to [useHotUpdaterStore()](./useHotUpdaterStore) for more information.


```tsx
function App() {
  const handleReload = () => {
    // Immediately reapply if there is a downloaded bundle
    await HotUpdater.reload(); // [!code hl]
  }

  return (
    
      Hello World

      
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```

---

# React Native API: "updateBundle"
URL: https://hot-updater.dev/docs/react-native-api/updateBundle
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/updateBundle.mdx

"The `updateBundle` function downloads and applies a new update bundle to your React Native application. It uses the provided bundle information obtained from `checkForUpdate`."

## Usage

Use `updateBundle` to download and apply an available update by providing the bundle's unique identifier and the URL to the bundle file.

```tsx
async function applyAppUpdate(updateInfo: UpdateInfo) {
  try {
    const updateInfo = await HotUpdater.checkForUpdate({
      source: getUpdateSource("", {
        updateStrategy: "appVersion", // or "fingerprint"
      }),
      requestHeaders: {
        Authorization: "Bearer ",
      },
    });

    if (!updateInfo) {
      return {
        status: "UP_TO_DATE",
      };
    }

    /**
     * You can apply updates using one of two methods:
     *
     * Method 1: (RECOMMENDED) Use the updateBundle() method from the updateInfo object
     * - A convenience method built into the return value from checkForUpdate
     * - Automatically includes fileHash for secure verification
     * - All required arguments are pre-filled from the checkForUpdate response
     */
    await updateInfo.updateBundle();

    /**
     * Method 2: Call HotUpdater.updateBundle() directly
     * - Explicitly pass the necessary values extracted from updateInfo
     * - You must manually include fileHash for security
     */
    // await HotUpdater.updateBundle({
    //   bundleId: updateInfo.id,
    //   fileUrl: updateInfo.fileUrl,
    //   fileHash: updateInfo.fileHash,
    //   status: updateInfo.status,
    // });


    if (updateInfo.shouldForceUpdate) {
      await HotUpdater.reload();
    }

    console.log("Update applied successfully");
  } catch (error) {
    console.error("Failed to apply update:", error);
  }
}
```

## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.


## Parameters

The `updateBundle` function accepts the following parameters:

| Parameter | Type      | Required | Description                             |
|-----------|-----------|----------|-----------------------------------------|
| `id`      | `string`  |         | Unique identifier of the update bundle. |
| `fileUrl` | `string`  |         | URL from which the update bundle will be downloaded. |
| `fileHash` | `string \| null`  |  Optional but recommended | SHA256 hash of the bundle file for integrity verification. If provided, the downloaded file will be verified before extraction. |

### Behavior

- Downloads the specified bundle from the provided `fileUrl`.
- **If `fileHash` is provided**: Verifies the downloaded file's SHA256 hash before extraction. If verification fails, the update is aborted and the downloaded file is deleted.
- **If `fileHash` is not provided**: Proceeds with extraction without hash verification (not recommended for production).
- Applies the downloaded bundle as the active bundle for the application.
- Requires an explicit call to `HotUpdater.reload()` if you want to immediately reload the application after updating, particularly when `shouldForceUpdate` is true.

### Security Recommendation

**Always provide `fileHash` in production environments.** Hash verification protects against:
- Man-in-the-middle attacks
- Corrupted downloads
- Tampered bundle files

#### Recommended Approach

**Use `updateInfo.updateBundle()` instead of `HotUpdater.updateBundle()`** whenever possible. The `updateInfo.updateBundle()` method automatically includes the `fileHash` from the `checkForUpdate()` response, ensuring secure verification without manual parameter passing.

```tsx
//  Recommended: fileHash is automatically included
const updateInfo = await checkForUpdate(/* ... */);
await updateInfo.updateBundle();

//  Less safe: you must remember to include fileHash manually
await HotUpdater.updateBundle({
  bundleId: updateInfo.id,
  fileUrl: updateInfo.fileUrl,
  fileHash: updateInfo.fileHash, // Easy to forget!
  status: updateInfo.status,
});
```

The `fileHash` is automatically included in the response from `checkForUpdate()` when your update server provides it.

---

# React Native API: "useHotUpdaterStore"
URL: https://hot-updater.dev/docs/react-native-api/useHotUpdaterStore
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/useHotUpdaterStore.mdx

"A store related to updates."

## Download Progress

`progress` is a number representing the bundle download progress. It has a value between 0 and 1.

When `isUpdateDownloaded` is `true`, it means the bundle download is complete and the update will be applied when `HotUpdater.reload()` is called. The `isUpdateDownloaded` becomes `true` when the `progress` value reaches 1.

```tsx
function App() {
  const { progress, isUpdateDownloaded } = useHotUpdaterStore();

  return (
    
      Hello World
      {Math.round(progress * 100)}%
       HotUpdater.reload()}
        disabled={!isUpdateDownloaded}
      />
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    Authorization: "Bearer ",
  },
})(App);
```

## Optimizing Renders with Selectors

You can optimize your component renders by using selectors to subscribe only to specific parts of the state. This prevents unnecessary re-renders when other parts of the state change.

```tsx
function ProgressDisplay() {
  // Only re-renders when progress changes
  const progress = useHotUpdaterStore(state => state.progress);

  return {Math.round(progress * 100)}%;
}

function UpdateButton() {
  // Only re-renders when isUpdateDownloaded changes
  const isUpdateDownloaded = useHotUpdaterStore(state => state.isUpdateDownloaded);

  return (
     HotUpdater.reload()}
      disabled={!isUpdateDownloaded}
    />
  );
}
```

---

# React Native API: "wrap"
URL: https://hot-updater.dev/docs/react-native-api/wrap
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/react-native-api/wrap.mdx

"`HotUpdater.wrap` checks for updates at the entry point, and if there is a bundle to update, it downloads the bundle and applies the update strategy."

## Usage
Use the `source` option in `HotUpdater.wrap` to specify the update server URL, then wrap the App entry point.

Since it uses fetch, if you need to pass headers along with it, you can use the `requestHeaders` option to pass headers.
```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({ // [!code hl:10]
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
})(App);
```


## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.


## Fallback Component

During an update check, access to the entry point is temporarily blocked while communicating with the server.

- If the update is **force update**, the entry point remains blocked, and the progress updates as the bundle downloads.  
- If **not force update**, the entry point is only blocked during the update check.

Without a `fallbackComponent`, the bundle downloads without blocking the screen.

### `fallbackComponent` Props:
- **`progress`**: Download progress (e.g., for a progress bar).  
- **`status`**: Update state:
  - `CHECK_FOR_UPDATE`: Checking for updates.  
  - `UPDATING`: Downloading the new bundle.  

Using these props, you can ensure a smooth UI transition.  
It is also recommended to include a **splash image** for a better user experience.
```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({ // [!code hl:26]
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  fallbackComponent: ({ progress, status, message }) => (
      
        {/* You can put a splash image here. */}

        
          {status === "UPDATING" ? "Updating..." : "Checking for Update..."}
        
        {message && (
          
            {message}
          
        )}
        {progress > 0 ? (
          
            {Math.round(progress * 100)}%
          
        ) : null}
      
    ),
  })(App);
```

## `reloadOnForceUpdate`

When a force update bundle is downloaded, the app will automatically reload. If `false`, `shouldForceUpdate` will be returned as `true` in `onUpdateProcessCompleted` but the app won't reload. default is `true`.

### `reloadOnForceUpdate` is `true`

When a force update exists, the app will automatically reload.

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  reloadOnForceUpdate: true, // Automatically reload the app on force updates // [!code hl]
})(App);
```


### `reloadOnForceUpdate` is `false`

When a force update exists, the app will not reload. `shouldForceUpdate` will be returned as `true` in `onUpdateProcessCompleted`.

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  reloadOnForceUpdate: false, // The app won't reload on force updates // [!code hl]
  onUpdateProcessCompleted: ({ status, shouldForceUpdate, id, message }) => {  // [!code hl]
    console.log("Bundle updated:", status, shouldForceUpdate, id, message);  // [!code hl]
    if (shouldForceUpdate) { // [!code hl]
      await HotUpdater.reload(); // [!code hl]
    } // [!code hl]
  },  // [!code hl]
})(App);
```

## onUpdateProcessCompleted

The `onUpdateProcessCompleted` option allows you to perform additional actions after the update process is completed.

### Callback Arguments

| Property | Type | Description |
|----------|-------------|-------------|
| `status` | "ROLLBACK" \| "UPDATE" \| "UP_TO_DATE" | The status of the update process |
| `shouldForceUpdate` | boolean | Whether the update process is forced |
| `id` | string | The ID of the bundle to update |
| `message` | string | The message of the update process |

```tsx
function App() {
  return (
    
      Hello World
    
  );
}

export default HotUpdater.wrap({
  source: getUpdateSource("", {
    updateStrategy: "appVersion", // or "fingerprint"
  }),
  // If you need to send request headers, you can use the `requestHeaders` option.
  requestHeaders: {
    "Authorization": "Bearer ",
  },
  onUpdateProcessCompleted: ({ status, shouldForceUpdate, id, message }) => {
    console.log("Bundle updated:", status, shouldForceUpdate, id, message);
  },

  // If you need to show the progress while downloading the new bundle, you can use the `onProgress` option.
  onProgress: ({ progress }) => {
    console.log("Bundle downloading progress:", progress);
  },
})(App);
```

## Update Strategy

| Update Type   | When Applied                                              | How to Enable                              |
|---------------|----------------------------------------------------------|-------------------------------------------|
| Default       | Downloads the update bundle in the background and applies it when the user restarts the app. | Default setting                           |
| Force Update  | Downloads the update bundle and applies it immediately.   | Use the `--force-update` flag or console. |


## Custom source Function

You can pass an async function to the source option for full control over how update info is fetched.

```tsx
export default HotUpdater.wrap({
  source: async () => {
    const res = await fetch("https://your.api/update-info");
    return (await res.json()) as AppUpdateInfo | null;
  },
  // ... other options
});
```

---

# Self-Hosted: "Self-Hosted Overview"
URL: https://hot-updater.dev/docs/self-hosted/overview
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/self-hosted/overview.mdx

"TODO: Document self-hosted deployment"

## Topics to Cover

- Self-hosted architecture
- Requirements
- Deployment options

---

# Self-Hosted: "Self-Hosted Provider"
URL: https://hot-updater.dev/docs/self-hosted/setup
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/self-hosted/setup.mdx

"Coming Soon"

Coming Soon

---

# Storage Plugins: "AWS S3 Storage"
URL: https://hot-updater.dev/docs/storage-plugins/aws
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/aws.mdx

Store your Hot Updater bundles in AWS S3 or any S3-compatible storage service (including Cloudflare R2).

## Installation

```package-install
npm install @hot-updater/aws --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [AWS](/docs/managed-providers/aws) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface S3StorageConfig {
  region: string;           // AWS region or 'auto' for R2
  bucketName: string;       // S3 bucket name
  basePath?: string;        // Optional base path within bucket
  endpoint?: string;        // Custom endpoint for S3-compatible services
  credentials?: {
    accessKeyId: string;
    secretAccessKey: string;
  };
}
```

## Usage

### AWS S3

```typescript
export default defineConfig({
  storage: s3Storage({
    region: 'us-east-1',
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY
    },
    bucketName: 'my-hot-updater-bucket'
  }),
  // ... other config
});
```

### Cloudflare R2

```typescript
export default defineConfig({
  storage: s3Storage({
    region: 'auto',
    endpoint: `https://${process.env.CLOUDFLARE_ACCOUNT_ID}.r2.cloudflarestorage.com`,
    credentials: {
      accessKeyId: process.env.R2_ACCESS_KEY_ID,
      secretAccessKey: process.env.R2_SECRET_ACCESS_KEY
    },
    bucketName: 'my-r2-bucket'
  }),
  // ... other config
});
```

## Protocol

`s3://`

This prefix is stored in the `storageUri` field in the database.

---

# Storage Plugins: "Cloudflare R2 Storage"
URL: https://hot-updater.dev/docs/storage-plugins/cloudflare
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/cloudflare.mdx

Store your Hot Updater bundles in Cloudflare R2 using the Wrangler CLI.

## Installation

```package-install
npm install @hot-updater/cloudflare --save-dev
```


For full R2 feature support including presigned URLs and better performance, use the S3-compatible AWS plugin. See the [AWS S3 Storage documentation](/docs/storage-plugins/aws) for more details.

Install the AWS plugin:

```package-install
npm install @hot-updater/aws --save-dev
```

Configure with R2:

```typescript
export default defineConfig({
  storage: s3Storage({
    region: 'auto',
    endpoint: 'https://your-account-id.r2.cloudflarestorage.com',
    credentials: {
      accessKeyId: 'your-r2-access-key-id',
      secretAccessKey: 'your-r2-secret-access-key'
    },
    bucketName: 'my-r2-bucket'
  }),
  // ... other config
});
```

This approach provides full R2 compatibility with better performance and all S3 features.


## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Cloudflare](/docs/managed-providers/cloudflare) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface R2StorageConfig {
  cloudflareApiToken: string;  // Cloudflare API token
  accountId: string;           // Cloudflare account ID
  bucketName: string;          // R2 bucket name
  basePath?: string;           // Optional base path within bucket
}
```

## Usage

```typescript
export default defineConfig({
  storage: r2Storage({
    accountId: process.env.CLOUDFLARE_ACCOUNT_ID,
    cloudflareApiToken: process.env.CLOUDFLARE_API_TOKEN,
    bucketName: 'my-r2-bucket'
  }),
  // ... other config
});
```

## Limitations

- Does not support getDownloadUrl() - bundles cannot be downloaded via presigned URLs
- Uses CLI instead of SDK (slower performance)
- Limited compared to S3-compatible approach

## Protocol

`r2://`

This prefix is stored in the `storageUri` field in the database.

---

# Storage Plugins: "Firebase Storage"
URL: https://hot-updater.dev/docs/storage-plugins/firebase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/firebase.mdx

Store your Hot Updater bundles in Firebase Cloud Storage.

## Installation

```package-install
npm install @hot-updater/firebase firebase-admin --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Firebase](/docs/managed-providers/firebase) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface FirebaseStorageConfig {
  projectId: string;               // Firebase project ID
  storageBucket: string;           // Storage bucket name
  credential: admin.credential.Credential;  // Firebase credential
  basePath?: string;               // Optional base path within bucket
}
```


## Environment Variables

Set up your Firebase credentials:

```bash title=".env.hotupdater"
# Project Settings > Service Accounts > New Private Key > Download JSON
GOOGLE_APPLICATION_CREDENTIALS=/path/to/your-service-account-key.json
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_STORAGE_BUCKET=your-bucket-name
```


## Usage

```typescript
// https://firebase.google.com/docs/admin/setup?hl=en#initialize_the_sdk_in_non-google_environments
// Check your .env file and add the credentials
// Set the GOOGLE_APPLICATION_CREDENTIALS environment variable to your credentials file path
// Example: GOOGLE_APPLICATION_CREDENTIALS=./firebase-adminsdk-credentials.json
const credential = admin.credential.applicationDefault();

export default defineConfig({
  storage: firebaseStorage({
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    credential
  }),
  // ... other config
});
```


## Protocol

`gs://`

This prefix is stored in the `storageUri` field in the database.

---

# Storage Plugins: "Standalone Storage"
URL: https://hot-updater.dev/docs/storage-plugins/standalone
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/standalone.mdx

Store your Hot Updater bundles in your custom self-hosted storage backend by implementing HTTP API endpoints.

## Installation

```package-install
npm install @hot-updater/standalone --save-dev
```

## Configuration

```typescript
interface StandaloneStorageConfig {
  baseUrl: string;                        // Your API base URL
  commonHeaders?: Record; // Headers sent with all requests
  routes?: StorageRoutes;                 // Optional custom route configuration
}

interface StorageRoutes {
  upload: (key: string, filePath: string) => RouteConfig;
  delete: (storageUri: string) => RouteConfig;
  getDownloadUrl: (storageUri: string) => RouteConfig;
}
```

## Usage

```typescript
export default defineConfig({
  storage: standaloneStorage({
    baseUrl: process.env.STORAGE_API_URL,
    commonHeaders: {
      'Authorization': `Bearer ${process.env.API_TOKEN}`
    }
  }),
  // ... other config
});
```

## API Endpoints

Your backend must implement these endpoints:

### POST /upload
Upload a bundle file.

**Request:**
- Method: `POST`
- Content-Type: `multipart/form-data`
- Body: File (`file` field) + key (`key` field)

**Response:**
```json
{
  "storageUri": "http://your-storage-uri"
}
```

### DELETE /delete
Delete a bundle.

**Request:**
- Method: `DELETE`
- Content-Type: `application/json`
- Body: `{ "storageUri": "http://your-storage-uri" }`

**Response:** 200 OK

### POST /getDownloadUrl
Get a download URL for a bundle.

**Request:**
- Method: `POST`
- Content-Type: `application/json`
- Body: `{ "storageUri": "http://your-storage-uri" }`

**Response:**
```json
{
  "fileUrl": "http://download-url"
}
```

## Custom Routes

You can customize the endpoint paths and headers:

```typescript
standaloneStorage({
  baseUrl: 'https://api.example.com',
  routes: {
    upload: (key, filePath) => ({
      path: `/v1/bundles/upload`,
      headers: { 'X-Bundle-Key': key }
    }),
    delete: (uri) => ({
      path: `/v1/bundles/delete`,
      headers: { 'X-Custom-Header': 'value' }
    }),
    getDownloadUrl: (uri) => ({
      path: `/v1/bundles/download-url`
    })
  }
})
```

## Protocol

`http://` or `https://`

This prefix is stored in the `storageUri` field in the database.

---

# Storage Plugins: "Supabase Storage"
URL: https://hot-updater.dev/docs/storage-plugins/supabase
Source: https://github.com/gronxb/hot-updater/blob/main/content/docs/storage-plugins/supabase.mdx

Store your Hot Updater bundles in Supabase Storage buckets.

## Installation

```package-install
npm install @hot-updater/supabase --save-dev
```

## Setup

The easiest way to set up your backend is using the init command:

```package-install
npx hot-updater init
```

This interactive command will guide you through the setup process. For details on what the init command does, see the [Supabase](/docs/managed-providers/supabase) documentation.

For manual configuration, use the settings below.

## Configuration

```typescript
interface SupabaseStorageConfig {
  supabaseUrl: string;       // Your Supabase project URL
  supabaseAnonKey: string;   // Your Supabase anon/public key
  bucketName: string;        // Storage bucket name
  basePath?: string;         // Optional base path within bucket
}
```

## Usage

```typescript
export default defineConfig({
  storage: supabaseStorage({
    supabaseUrl: process.env.SUPABASE_URL,
    supabaseAnonKey: process.env.SUPABASE_ANON_KEY,
    bucketName: 'hot-updater-bundles',
    basePath: 'bundles'  // Optional
  }),
  // ... other config
});
```

## Protocol

`supabase-storage://`

This prefix is stored in the `storageUri` field in the database.

---

