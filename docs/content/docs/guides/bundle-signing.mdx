---
title: "Bundle Signing"
description: "Cryptographically sign OTA bundles to verify integrity and prevent tampering"
icon: Shield
---

## Why Bundle Signing?

Bundle signing adds cryptographic verification to OTA updates. The server signs each bundle with a private key. The native app verifies the signature using the embedded public key before applying updates.

This prevents:
- **Man-in-the-middle attacks**: Attackers cannot inject malicious code
- **Bundle tampering**: Any modification invalidates the signature
- **Unauthorized deployments**: Only bundles signed with your private key are accepted

## Quick Start

```bash
# 1. Generate RSA key pair
npx hot-updater keys generate

# 2. Add signing config to hot-updater.config.ts
# signing: { enabled: true, privateKeyPath: "./keys/private-key.pem" }

# 3. Export public key to native apps
npx hot-updater keys export-public

# 4. Release new app version, then deploy signed bundles
npx hot-updater deploy -p ios
```

> **Important**: Step 3 embeds the public key in your native app binary. You must release a new version to the App Store / Play Store before deploying signed bundles. OTA updates will fail signature verification until users have the app version containing the public key.

## Step 1: Generate Key Pair

Generate an RSA key pair using the `keys generate` command:

```bash
npx hot-updater keys generate
```

This creates two files in the `./keys` directory:
- `private-key.pem`: Keep secure, use for signing bundles (server-side only)
- `public-key.pem`: Embed in native apps for verification

### Command Options

| Option | Description | Default |
|--------|-------------|---------|
| `-o, --output <dir>` | Output directory for keys | `./keys` |
| `-k, --key-size <size>` | RSA key size (2048 or 4096) | `4096` |

Example with custom options:

```bash
npx hot-updater keys generate --output ./secure-keys --key-size 4096
```

> Never commit private keys to version control. Add `keys/` to `.gitignore`. For CI/CD pipelines, use secure storage like AWS Secrets Manager, HashiCorp Vault, or GitHub Secrets.

## Step 2: Configure Signing

Enable signing in your `hot-updater.config.ts`:

```ts title="hot-updater.config.ts"
import { bare } from "@hot-updater/bare";
import { supabaseDatabase, supabaseStorage } from "@hot-updater/supabase";
import { defineConfig } from "hot-updater";

export default defineConfig({
  build: bare({ enableHermes: true }),
  storage: supabaseStorage({ /* ... */ }),
  database: supabaseDatabase({ /* ... */ }),
  signing: {
    enabled: true,
    privateKeyPath: "./keys/private-key.pem",
  },
});
```

### Configuration Options

```ts
type SigningConfig =
  | {
      /** Signing disabled - privateKeyPath is optional */
      enabled: false;
      privateKeyPath?: string;
    }
  | {
      /** Signing enabled - privateKeyPath is required */
      enabled: true;
      /** Path to RSA private key file (PEM format, PKCS#8) */
      privateKeyPath: string;
    };
```

When `signing.enabled` is true, the deploy command will:
1. Generate SHA-256 hash of the bundle
2. Sign the hash with RSA-SHA256 using your private key
3. Store the signature in the fileHash field (the hash is implicitly verified during signature verification)

## Step 3: Export Public Key to Native Apps

Export the public key and embed it in your native configuration files:

```bash
npx hot-updater keys export-public
```

This command reads the private key path from `signing.privateKeyPath` in your config and:
1. Extracts the public key from the private key
2. Writes it to iOS `Info.plist` (`HOT_UPDATER_PUBLIC_KEY`)
3. Writes it to Android `strings.xml` (`hot_updater_public_key`)

### Command Options

| Option | Description |
|--------|-------------|
| `-i, --input <path>` | Override private key path |
| `-p, --print-only` | Display key without modifying files |
| `-y, --yes` | Skip confirmation prompts |

### Manual Configuration

For iOS (`Info.plist`):
```xml
<key>HOT_UPDATER_PUBLIC_KEY</key>
<string>-----BEGIN PUBLIC KEY-----\nMIIB...your-key...\n-----END PUBLIC KEY-----</string>
```

For Android (`res/values/strings.xml`):
```xml
<string name="hot_updater_public_key">-----BEGIN PUBLIC KEY-----
MIIBIjANBgkq...your-key...
-----END PUBLIC KEY-----</string>
```

> After embedding the public key, you must rebuild your native app. The native code reads this key at runtime to verify bundle signatures.

## Step 4: Deploy Signed Bundles

Deploy bundles as usual. When signing is enabled, the deploy command automatically signs each bundle:

```bash
npx hot-updater deploy -p ios
```

Console output when signing is enabled:

```
Building Bundle (bare)
Signing bundle
Bundle signed (dG9rZW5fc2lnbmF0...)
Signature algorithm: RSA-SHA256
Build Complete (bare)
Uploading to Storage (supabaseStorage)
Upload Complete (supabaseStorage)
Updating Database (supabaseDatabase)
Update Complete (supabaseDatabase)
Deployment Successful
```

### How Verification Works

1. Client app downloads update metadata (fileHash contains signature for signed bundles)
2. Client app downloads bundle and computes SHA-256 hash
3. Native code verifies signature against computed hash using public key
4. If verification fails, bundle is rejected

### FileHash Format

Signed bundles store only the signature in the fileHash field:

```
sig:<base64_signature>
```

**Components**:
- `sig:` - Prefix indicating signed bundle
- `<base64_signature>` - Base64-encoded RSA-SHA256 signature

The hash is not stored because RSA-SHA256 signature verification implicitly validates the bundle hash. The native app computes the hash from the downloaded bundle and verifies it against the signature.

Unsigned bundles use the plain SHA256 hash format:

```
<hex_hash>
```

## Security Best Practices

### Key Storage

- Never commit private keys to version control
- Add `keys/` to `.gitignore`
- Use file permissions: `chmod 600 private-key.pem`

### CI/CD Integration

Store private keys in secure secrets management:

| Platform | Secret Storage |
|----------|----------------|
| GitHub Actions | Repository Secrets |
| GitLab CI | CI/CD Variables (masked) |
| AWS | Secrets Manager |
| Azure | Key Vault |

Example GitHub Actions workflow:

```yaml
- name: Setup signing key
  run: |
    mkdir -p keys
    echo "${{ secrets.HOT_UPDATER_PRIVATE_KEY }}" > keys/private-key.pem
    chmod 600 keys/private-key.pem

- name: Deploy
  run: npx hot-updater deploy -p ios
```

### Key Rotation

When rotating keys:
1. Generate new key pair
2. Update config with new private key path
3. Export new public key to native apps
4. Release new native app version
5. Maintain backward compatibility until users update

## Configuration State Matrix

Understanding the relationship between your config file and native app settings is critical for proper signing behavior.

<Callout type="warn">
**Configuration Mismatch Warning**: The config file (`signing.enabled`) and native files (public keys) must be in sync. Mismatches cause updates to fail.
</Callout>

| Config `signing.enabled` | Native Public Key | Behavior |
|--------------------------|-------------------|----------|
| `false` | Not present | ✅ Normal updates (no verification) |
| `false` | **Present** | ❌ **Updates rejected** - app expects signatures |
| `true` | Present | ✅ Signature verified, update proceeds |
| `true` | **Not present** | ❌ **Error: PublicKeyNotConfigured** |

## Troubleshooting

### Updates Rejected - App Expects Signatures

**Error**: Deployment succeeds but app rejects updates.

**Cause**: Public key exists in native files but `signing.enabled` is `false` in config.

**Solution**: Either enable signing in config, or remove public keys:
```bash
# Option 1: Enable signing
# Set signing.enabled: true in hot-updater.config.ts

# Option 2: Remove public keys (then rebuild native app)
npx hot-updater keys remove
```

### PublicKeyNotConfigured Error

**Error**: `PublicKeyNotConfigured` when app tries to verify bundle.

**Cause**: `signing.enabled` is `true` but public key is missing from native files.

**Solution**: Export public key to native files and rebuild:
```bash
npx hot-updater keys export-public
# Then rebuild and release native app
```

### Signature Verification Failed

**Error**: Bundle downloaded but signature verification fails.

**Possible Causes**:
1. Bundle was tampered with during transit
2. Wrong public key in native app (key rotation issue)
3. Bundle signed with different private key

**Solution**: Verify you're using matching key pairs. Re-export public key if needed:
```bash
npx hot-updater keys export-public --print-only
# Compare with key in native files
```

### Deploy Warning About Orphan Public Keys

**Warning**: "Signing is disabled but public keys found in native files"

**Cause**: Config has `signing.enabled: false` but native files contain public keys.

**Solution**: Remove orphan public keys:
```bash
npx hot-updater keys remove
# Then rebuild and release native app
```

## CLI Commands Reference

### `keys generate`

Generate RSA key pair for code signing.

```bash
npx hot-updater keys generate [options]
```

| Option | Description | Default |
|--------|-------------|---------|
| `-o, --output <dir>` | Output directory for keys | `./keys` |
| `-k, --key-size <size>` | RSA key size (2048 or 4096) | `4096` |

### `keys export-public`

Export public key to native configuration files.

```bash
npx hot-updater keys export-public [options]
```

| Option | Description |
|--------|-------------|
| `-i, --input <path>` | Override private key path (default: from config) |
| `-p, --print-only` | Display key without modifying files |
| `-y, --yes` | Skip confirmation prompt |

### `keys remove`

Remove public keys from native configuration files.

```bash
npx hot-updater keys remove [options]
```

| Option | Description |
|--------|-------------|
| `-y, --yes` | Skip confirmation prompt |

## Disabling Bundle Signing

To disable bundle signing after it was previously enabled, you must update both the config file AND remove public keys from native apps.

<Callout type="warn">
**Both Steps Required**: If you only disable signing in config but leave public keys in native files, updates will fail. The native app will still expect signatures.
</Callout>

### Step-by-Step Guide

**1. Update your config file:**

```ts title="hot-updater.config.ts"
export default defineConfig({
  // ... other config
  signing: {
    enabled: false,
  },
});
```

**2. Remove public keys from native files:**

```bash
npx hot-updater keys remove
```

This command automatically detects and removes public keys from both platforms:
- iOS: Removes `HOT_UPDATER_PUBLIC_KEY` from `Info.plist`
- Android: Removes `hot_updater_public_key` from `strings.xml`

**3. Rebuild and release your native app:**

After removing the public keys, you must release a new version of your app to the App Store / Play Store. Users with the old app version (containing public keys) will reject unsigned bundles until they update.

**4. Deploy unsigned bundles:**

```bash
npx hot-updater deploy -p ios
```

### `keys remove` Command Options

| Option | Description |
|--------|-------------|
| `-y, --yes` | Skip confirmation prompt |

## Quick Reference

### Enable Signing Checklist

1. ☐ Generate keys: `npx hot-updater keys generate`
2. ☐ Update config: `signing: { enabled: true, privateKeyPath: "./keys/private-key.pem" }`
3. ☐ Export public key: `npx hot-updater keys export-public`
4. ☐ Add `keys/` to `.gitignore`
5. ☐ Rebuild native app
6. ☐ Release to App Store / Play Store
7. ☐ Deploy signed bundles: `npx hot-updater deploy`

### Disable Signing Checklist

1. ☐ Update config: `signing: { enabled: false }`
2. ☐ Remove public keys: `npx hot-updater keys remove`
3. ☐ Rebuild native app
4. ☐ Release to App Store / Play Store
5. ☐ Deploy unsigned bundles: `npx hot-updater deploy`
