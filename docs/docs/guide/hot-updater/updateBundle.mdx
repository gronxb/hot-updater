# `HotUpdater.updateBundle()`

The `updateBundle` function downloads and applies a new update bundle to your React Native application. It uses the provided bundle information obtained from `checkForUpdate`.

This method is particularly useful when you need a custom update strategy without using the built-in `wrap` method.

## Usage

Use `updateBundle` to download and apply an available update by providing the bundle's unique identifier and the URL to the bundle file.

```tsx
import { HotUpdater, getUpdateSource } from "@hot-updater/react-native";

async function applyAppUpdate(updateInfo: UpdateInfo) {
  try {
    const updateInfo = await HotUpdater.checkForUpdate({
      source: getUpdateSource("<your-update-server-url>", {
        updateStrategy: "appVersion", // or "fingerprint"
      }),
      requestHeaders: {
        Authorization: "Bearer <your-access-token>",
      },
    });

    if (!updateInfo) {
      return {
        status: "UP_TO_DATE",
      };
    }

    /**
     * You can apply updates using one of two methods:
     *
     * Method 1: (RECOMMENDED) Use the updateBundle() method from the updateInfo object
     * - A convenience method built into the return value from checkForUpdate
     * - Automatically includes fileHash for secure verification
     * - All required arguments are pre-filled from the checkForUpdate response
     */
    await updateInfo.updateBundle();

    /**
     * Method 2: Call HotUpdater.updateBundle() directly
     * - Explicitly pass the necessary values extracted from updateInfo
     * - You must manually include fileHash for security
     */
    // await HotUpdater.updateBundle({
    //   bundleId: updateInfo.id,
    //   fileUrl: updateInfo.fileUrl,
    //   fileHash: updateInfo.fileHash,
    //   status: updateInfo.status,
    // });


    if (updateInfo.shouldForceUpdate) {
      await HotUpdater.reload();
    }

    console.log("Update applied successfully");
  } catch (error) {
    console.error("Failed to apply update:", error);
  }
}
```

## Understanding `getUpdateSource`

The `getUpdateSource` function is used to construct the final URL for checking for updates. It takes a `baseUrl` as its first argument and an options object as its second argument. The `updateStrategy` property within the options object determines the final structure of the request URL.

**Example Final Endpoint Structures:**

Depending on the `updateStrategy` value, `getUpdateSource` generates URLs like the following:

*   For `updateStrategy: 'appVersion'`: `GET {baseUrl}/app-version/:platform/:appVersion/:channel/:minBundleId/:bundleId`
*   For `updateStrategy: 'fingerprint'`: `GET {baseUrl}/fingerprint/:platform/:fingerprintHash/:channel/:minBundleId/:bundleId`

For example, if you provide `https://your-update-server.com/api/update-check` as the `baseUrl`, `getUpdateSource` will append the correct path and parameters to the URL depending on whether `updateStrategy` is `'appVersion'` or `'fingerprint'`.


## Parameters

The `updateBundle` function accepts the following parameters:

| Parameter | Type      | Required | Description                             |
|-----------|-----------|----------|-----------------------------------------|
| `id`      | `string`  | ✅        | Unique identifier of the update bundle. |
| `fileUrl` | `string`  | ✅        | URL from which the update bundle will be downloaded. |
| `fileHash` | `string \| null`  | ⚠️ Optional but recommended | SHA256 hash of the bundle file for integrity verification. If provided, the downloaded file will be verified before extraction. |

### Behavior

- Downloads the specified bundle from the provided `fileUrl`.
- **If `fileHash` is provided**: Verifies the downloaded file's SHA256 hash before extraction. If verification fails, the update is aborted and the downloaded file is deleted.
- **If `fileHash` is not provided**: Proceeds with extraction without hash verification (not recommended for production).
- Applies the downloaded bundle as the active bundle for the application.
- Requires an explicit call to `HotUpdater.reload()` if you want to immediately reload the application after updating, particularly when `shouldForceUpdate` is true.

### Security Recommendation

**Always provide `fileHash` in production environments.** Hash verification protects against:
- Man-in-the-middle attacks
- Corrupted downloads
- Tampered bundle files

#### Recommended Approach

**Use `updateInfo.updateBundle()` instead of `HotUpdater.updateBundle()`** whenever possible. The `updateInfo.updateBundle()` method automatically includes the `fileHash` from the `checkForUpdate()` response, ensuring secure verification without manual parameter passing.

```tsx
// ✅ Recommended: fileHash is automatically included
const updateInfo = await checkForUpdate(/* ... */);
await updateInfo.updateBundle();

// ⚠️ Less safe: you must remember to include fileHash manually
await HotUpdater.updateBundle({
  bundleId: updateInfo.id,
  fileUrl: updateInfo.fileUrl,
  fileHash: updateInfo.fileHash, // Easy to forget!
  status: updateInfo.status,
});
```

The `fileHash` is automatically included in the response from `checkForUpdate()` when your update server provides it.
